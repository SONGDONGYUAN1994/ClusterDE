[{"path":"https://songdongyuan1994.github.io/ClusterDE/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 ClusterDE authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-PBMC.html","id":"download-data","dir":"Articles","previous_headings":"","what":"Download data","title":"Perform ClusterDE on a PBMC dataset","text":"PBMC datasets originally SeuratData. use one (10x Chromium (v3) PBMC1 replicate). filtered lowly epxressed genes save computational time .","code":"# InstallData(\"pbmcsca\") # data(\"pbmcsca\") # pbmc <- pbmcsca[, pbmcsca@meta.data$Method==\"10x Chromium (v3)\" & pbmcsca@meta.data$Experiment == \"pbmc1\"] #  # pbmc <- pbmc[Matrix::rowSums(pbmc@assays$RNA@counts) > 100, ]  pbmc <- readRDS(url(\"https://figshare.com/ndownloader/files/41486283\"))"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-PBMC.html","id":"run-the-regular-seurat-pipeline","dir":"Articles","previous_headings":"","what":"Run the regular Seurat pipeline","title":"Perform ClusterDE on a PBMC dataset","text":"perform default Seurat clustering. Note real data analysis, cell type label usually unknown.  vignette, interested cluster 2 vs 8, approximately represent CD14+/CD16+ monocytes. Please note ClusterDE designed 1 vs 1 comparison. Therefore, users may (1) choose two interested clusters manually based knowledge (2) use two locally closest clusters computation (e.g., BuildClusterTree Seurat).  perform DE test cluster 2 8. subset cluster 2 8 (pbmc_sub). Note: since need number genes tested real data null data, manually remove default filtering Seurat, exclude genes test. believe fitering performed test every gene.","code":"RNGkind(\"L'Ecuyer-CMRG\") set.seed(123) pbmc <- UpdateSeuratObject(pbmc) ## Avoid errors #> Validating object structure #> Updating object slots #> Ensuring keys are in the proper structure #> Warning: Assay RNA changing from Assay to Assay #> Ensuring keys are in the proper structure #> Ensuring feature names don't have underscores or pipes #> Updating slots in RNA #> Validating object structure for Assay 'RNA' #> Object representation is consistent with the most current Seurat version pbmc <- NormalizeData(pbmc) pbmc <- FindVariableFeatures(object = pbmc) pbmc <- ScaleData(object = pbmc) #> Centering and scaling data matrix pbmc <- RunPCA(object = pbmc) #> PC_ 1  #> Positive:  IL32, CCL5, TRBC2, TRAC, CD69, CST7, RORA, CTSW, SPOCK2, ITM2A  #>     GZMM, CD247, TRBC1, C12orf75, IL7R, CD8A, CD2, LDHB, GZMA, CD7  #>     NKG7, CD6, GZMH, CD8B, BCL11B, PRF1, LYAR, LTB, FGFBP2, TCF7  #> Negative:  LYZ, FCN1, CLEC7A, CPVL, SERPINA1, SPI1, S100A9, AIF1, NAMPT, CSTA  #>     CTSS, MAFB, MPEG1, NCF2, VCAN, FGL2, S100A8, TYMP, CST3, LST1  #>     CYBB, CFD, FCER1G, SLC11A1, TGFBI, GRN, CD14, PSAP, SLC7A7, MS4A6A  #> PC_ 2  #> Positive:  RPL10, EEF1A1, TMSB10, RPS2, RPS12, RPL13, RPS18, RPS23, RPLP1, TPT1  #>     RPS8, IL32, S100A4, PFN1, RPLP0, NKG7, ARL4C, HSPA8, CST7, ZFP36L2  #>     ANXA1, CTSW, S100A6, LDHA, CORO1A, CD247, GZMA, CALR, S100A10, GZMM  #> Negative:  NRGN, PF4, SDPR, HIST1H2AC, MAP3K7CL, PPBP, GNG11, GPX1, TUBB1, SPARC  #>     CLU, PGRMC1, FTH1, RGS18, MARCH2, TREML1, HIST1H3H, AP003068.23, NCOA4, ACRBP  #>     TAGLN2, PRKAR2B, CD9, CA2, CMTM5, CTTN, MTURN, TMSB4X, HIST1H2BJ, TSC22D1  #> PC_ 3  #> Positive:  CD79A, HLA-DQA1, MS4A1, LINC00926, IGHM, BANK1, IGHD, TNFRSF13C, HLA-DQB1, CD74  #>     IGKC, HLA-DRA, BLK, CD83, CD37, CD22, ADAM28, JUND, NFKBID, HLA-DRB1  #>     P2RX5, CD79B, VPREB3, IGLC2, FCER2, RPS8, LTB, RPS23, TCOF1, GNG7  #> Negative:  CCL5, TMSB4X, SRGN, NKG7, ACTB, CST7, GZMH, FGFBP2, CTSW, PRF1  #>     GZMA, GZMB, C12orf75, S100A4, ANXA1, KLRD1, NRGN, GNLY, GZMM, IL32  #>     PF4, SDPR, PPBP, MYO1F, CD247, GAPDH, MAP3K7CL, HIST1H2AC, GNG11, TUBB1  #> PC_ 4  #> Positive:  FCGR3A, GZMB, FGFBP2, GZMH, NKG7, HLA-DPA1, PRF1, HLA-DPB1, CST7, GNLY  #>     KLRD1, HLA-DRB1, GZMA, CCL5, SPON2, ADGRG1, CTSW, ZEB2, PRSS23, IFITM2  #>     CCL4, CD74, KLRF1, RHOC, MTSS1, CDKN1C, CD79B, CEP78, HLA-DQA1, CLIC3  #> Negative:  IL7R, LEPROTL1, LTB, RCAN3, MAL, LEF1, TCF7, ZFP36L2, CAMK4, VIM  #>     LDHB, NOSIP, JUNB, SLC2A3, TRABD2A, RGCC, SATB1, TNFAIP3, TMEM123, SOCS3  #>     AQP3, BCL11B, NELL2, TNFRSF25, CD28, PABPC1, DNAJB1, TRAT1, OXNAD1, TRAC  #> PC_ 5  #> Positive:  CDKN1C, HES4, CSF1R, CKB, ZNF703, TCF7L2, CTSL, MS4A7, PAG1, FAM110A  #>     SIGLEC10, LRRC25, FCGR3A, LTB, RNASET2, CDH23, IL7R, RRAS, LINC01272, IFITM3  #>     LST1, LILRB2, PILRA, RHOC, SLC2A6, PECAM1, CAMK1, TAGLN, IFI30, BID  #> Negative:  VCAN, S100A12, S100A8, CD14, CSF3R, ITGAM, CST7, GZMB, MT-CO1, GNLY  #>     KLRD1, PRF1, MS4A6A, GZMH, FGFBP2, CD93, EGR1, NKG7, S100A9, MT-CO3  #>     IER3, THBS1, RNASE6, CLEC4E, MGST1, CTSW, SGK1, GZMA, RP11-1143G9.4, CH17-373J23.1 pbmc <- FindNeighbors(object = pbmc) #> Computing nearest neighbor graph #> Computing SNN pbmc <- FindClusters(object = pbmc, resolution = 0.3) #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 3222 #> Number of edges: 108605 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.9363 #> Number of communities: 10 #> Elapsed time: 0 seconds pbmc <- RunUMAP(object = pbmc, dims = 1:10) #> Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric #> To use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation' #> This message will be shown once per session #> 18:37:33 UMAP embedding parameters a = 0.9922 b = 1.112 #> 18:37:33 Read 3222 rows and found 10 numeric columns #> 18:37:33 Using Annoy for neighbor search, n_neighbors = 30 #> 18:37:33 Building Annoy index with metric = cosine, n_trees = 50 #> 0%   10   20   30   40   50   60   70   80   90   100% #> [----|----|----|----|----|----|----|----|----|----| #> **************************************************| #> 18:37:34 Writing NN index file to temp file /tmp/RtmpZ1MPPX/file1961654ec98e #> 18:37:34 Searching Annoy index using 1 thread, search_k = 3000 #> 18:37:34 Annoy recall = 100% #> 18:37:35 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30 #> 18:37:36 Initializing from normalized Laplacian + noise (using RSpectra) #> 18:37:36 Commencing optimization for 500 epochs, with 126446 positive edges #> 18:37:40 Optimization finished p1 <- DimPlot(object = pbmc, reduction = \"umap\", label = TRUE) + ggtitle(\"Clustering result\") + NoLegend() p2 <- DimPlot(object = pbmc, reduction = \"umap\", group.by = \"CellType\", label = TRUE) + NoLegend() p1 + p2 pbmc <- BuildClusterTree(pbmc) PlotClusterTree(pbmc) pbmc_sub <- subset(x = pbmc, idents = c(2, 8)) original_markers <- FindMarkers(pbmc_sub,                                  ident.1 = 2,                                  ident.2 = 8,                                  min.pct = 0,                                  logfc.threshold = 0) #> For a (much!) faster implementation of the Wilcoxon Rank Sum Test, #> (default method for FindMarkers) please install the presto package #> -------------------------------------------- #> install.packages('devtools') #> devtools::install_github('immunogenomics/presto') #> -------------------------------------------- #> After installation of presto, Seurat will automatically use the more  #> efficient implementation (no further action necessary). #> This message will be shown once per session"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-PBMC.html","id":"generate-synthetic-null-data","dir":"Articles","previous_headings":"","what":"Generate synthetic null data","title":"Perform ClusterDE on a PBMC dataset","text":"first generate synthetic null data based target data (real subset data, pbmc_sub, contains two clusters interested ). can increase number cores (CPUs) speed . perform pipeline target data. Please note need two clusters , . straightforward clustering method predefined cluster numbers, e.g., K-means. louvain clustering used Seurat may manually adjust resolution parameter still get two clusters.  perform DE test synthetic null data. extract p-values original data synthetic null data, use ClusterDE “compare” . can check summary table. genes ranked “contrast score (cs)”. compare result naive Seurat pipeline ClusterDE, first visualize top 6 DE genes Seurat. Genes LST1 RPS19 highly expressed two clusters. addition, RPS19 reported stable housekeeping genes several studies. Note mean expression levels LST1 RPS19 two cell types. means good cell type markers. Philosophically speaking, means conditional two clusters obtained clustering algorithm, LST1 RPS19 less likely cell type markers two cell types. contrast, genes ClusterDE LST1 RPS19 anymore.","code":"count_mat <- GetAssayData(object = pbmc_sub, slot = \"counts\") #> Warning: The `slot` argument of `GetAssayData()` is deprecated as of SeuratObject 5.0.0. #> ℹ Please use the `layer` argument instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. set.seed(1234) system.time(synthetic_null <- ClusterDE::constructNull(count_mat, nCores = 2, fastVersion = TRUE)) #> 130 genes have no more than 2 non-zero values; ignore fitting and return all 0s. #> 64.5% of genes are used in correlation modelling. #>    user  system elapsed  #>  84.829  56.279  40.435 pbmc_null <- CreateSeuratObject(counts = synthetic_null)  set.seed(123) pbmc_null <- NormalizeData(object = pbmc_null) #> Normalizing layer: counts pbmc_null <- FindVariableFeatures(object = pbmc_null) #> Finding variable features for layer counts pbmc_null <- ScaleData(object = pbmc_null) #> Centering and scaling data matrix pbmc_null <- RunPCA(object = pbmc_null) #> PC_ 1  #> Positive:  RPS19, PFN1, AIF1, RPS27, LST1, RPL8, YBX1, COTL1, RPL41, RNASET2  #>     FTL, IFITM3, FCGR3A, RPL10, IFITM2, FTH1, NACA, FCER1G, TMSB4X, SOD1  #>     RPS29, B2M, GNAI2, HLA-B, RHOC, HLA-C, TMSB10, FAU, RPL19, MS4A7  #> Negative:  VCAN, FOS, S100A8, LYZ, S100A9, SLC2A3, CD14, CSF3R, S100A12, IRF2BP2  #>     GPX1, MS4A6A, ITGAM, FOSB, DUSP6, CD36, CYP1B1, PPIF, SELL, RP11-1143G9.4  #>     ZFP36L1, NFKBIA, RGS2, CD93, SGK1, RNASE6, CD99, STAB1, NCF1, CEBPD  #> PC_ 2  #> Positive:  CDKN1C, MALAT1, FAM110A, SLC2A6, FCGR3A, MTSS1, RRAS, TCF7L2, KLF2, PECAM1  #>     PAG1, LYST, RHOC, SOD1, ABI3, CYFIP2, CKB, SPN, TPTEP1, ADA  #>     HES4, CDH23, LTB, SLC44A2, PHTF2, PIK3CG, CAT, ITGAX, SNX9, CD79B  #> Negative:  TPT1, RPS13, GAPDH, RPS3A, RPS18, RPLP0, HLA-DRA, RPL18A, EEF1A1, RPS2  #>     GPX1, HLA-DRB1, RPL37A, CPVL, RPS8, RPL28, RPS6, CD74, RPL23A, RPL3  #>     RPS14, RPS4X, RPL26, RPL11, RPS12, FCN1, RPL37, RPL30, LYZ, RPL10  #> PC_ 3  #> Positive:  HLA-DRA, MARCKSL1, HLA-DPB1, HLA-DPA1, APOBEC3A, HLA-DRB1, EMP3, CD74, MARCKS, CPVL  #>     CD300E, DUSP6, HLA-DMB, DOK2, CST3, HLA-DQB1, NAAA, CEBPB, RUNX3, SRC  #>     RGCC, MAFB, TIMP1, MAP3K8, TLE3, CDKN1A, UTRN, ZMIZ1, HMOX1, IFI30  #> Negative:  HMGB2, FYN, RPS3, IRS2, S100A8, ZFP36L2, RPS15A, S100A9, ADD3, ALOX5AP  #>     S100A12, SELL, UBE2D1, FAM65B, RGS2, RPS4X, PYGL, SORL1, PLBD1, CREBRF  #>     SAMSN1, RPL30, YPEL3, RPS6, RPL3, SOD2, RNF144B, EMB, RPS12, CNOT6L  #> PC_ 4  #> Positive:  MALAT1, ARL4C, KCNAB2, LUC7L3, NKG7, SFT2D2, LINC00657, C5orf56, FAM133B, ZNF292  #>     SORL1, LPP, PRRC2B, ZNF652, KLF9, BTG1, TMC6, YTHDC1, DDX6, RPS6KA3  #>     DDHD1, SIGIRR, TTC14, GADD45B, PHKB, KDM7A, HBEGF, DENND1B, LBR, TOB1  #> Negative:  S100A4, FTL, S100A11, CXCL8, FTH1, SERPINA1, S100A8, NCF1, ACTG1, DUSP6  #>     FAM26F, ACTB, RGS2, FAU, FOS, COTL1, S100A9, S100A6, DIS3L2, SNAP23  #>     SAT1, BCL2A1, CFD, CTB-61M7.2, PRELID1, S100A12, PLAUR, TRAC, AIF1, RHOB  #> PC_ 5  #> Positive:  TUBA1A, TNFAIP3, ZCCHC8, LINC00657, APOBEC3A, DDX6, CIRBP, PLAUR, VASP, SNRK  #>     KMT2A, S1PR3, INSIG1, BHLHE40, EHD1, B2M, LILRA1, ARHGAP15, RUNX3, PDE4B  #>     EML4, DSTN, KIAA0430, FAM107B, PTGS2, WDFY1, PSMD1, TMX4, RPL30, CTNNB1  #> Negative:  FAM102B, CEP63, ANXA1, CACUL1, TIMP1, UTP14A, TYW5, KAT8, SNHG9, C6orf226  #>     OAS1, JUN, IRF8, AATF, TMEM55B, NAGK, YIPF4, TAGLN2, YDJC, SERTAD3  #>     ADAM28, POMT1, LRP10, LMNA, SNX10, LPAR6, RAB37, HSPBP1, LPP, TSPAN17 pbmc_null <- FindNeighbors(object = pbmc_null) #> Computing nearest neighbor graph #> Computing SNN pbmc_null <- FindClusters(object = pbmc_null, resolution = 0.3) #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 453 #> Number of edges: 18383 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.7450 #> Number of communities: 2 #> Elapsed time: 0 seconds pbmc_null <- RunUMAP(object = pbmc_null, dims = 1:10) #> 18:38:47 UMAP embedding parameters a = 0.9922 b = 1.112 #> 18:38:47 Read 453 rows and found 10 numeric columns #> 18:38:47 Using Annoy for neighbor search, n_neighbors = 30 #> 18:38:47 Building Annoy index with metric = cosine, n_trees = 50 #> 0%   10   20   30   40   50   60   70   80   90   100% #> [----|----|----|----|----|----|----|----|----|----| #> **************************************************| #> 18:38:47 Writing NN index file to temp file /tmp/RtmpZ1MPPX/file19611689a49d #> 18:38:47 Searching Annoy index using 1 thread, search_k = 3000 #> 18:38:47 Annoy recall = 100% #> 18:38:48 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30 #> 18:38:49 Initializing from normalized Laplacian + noise (using RSpectra) #> 18:38:49 Commencing optimization for 500 epochs, with 17726 positive edges #> 18:38:50 Optimization finished DimPlot(object = pbmc_null, reduction = \"umap\") null_markers <- FindMarkers(pbmc_null,                              ident.1 = 0,                              ident.2 = 1,                              min.pct = 0,                              logfc.threshold = 0) original_pval <- original_markers$p_val names(original_pval) <- rownames(original_markers)  null_pval <- null_markers$p_val names(null_pval) <- rownames(null_markers)  res <- ClusterDE::callDE(original_pval, null_pval, nlogTrans = TRUE, FDR = 0.05) head(res$summaryTable) #> # A tibble: 6 × 5 #>   Gene   target  null    cs      q #>   <chr>   <dbl> <dbl> <dbl>  <dbl> #> 1 FCGR3A   79.0  45.1  33.9 0.0123 #> 2 CKB      44.6  13.1  31.5 0.0123 #> 3 CDKN1C   67.5  37.2  30.3 0.0123 #> 4 CD79B    53.1  25.5  27.7 0.0123 #> 5 RHOC     65.8  39.5  26.2 0.0123 #> 6 PLD4     36.2  13.6  22.6 0.0123 FeaturePlot(pbmc[ , pbmc$seurat_clusters %in% c(2, 8)], features = c(rownames(original_markers)[1:6]), ncol = 3) FeaturePlot(pbmc[, pbmc$seurat_clusters %in% c(2, 8)], features = c(res$summaryTable$Gene[1:6]), ncol = 3)"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-PBMC.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Perform ClusterDE on a PBMC dataset","text":"","code":"sessionInfo() #> R version 4.4.1 (2024-06-14) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.4 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> Random number generation: #>  RNG:     L'Ecuyer-CMRG  #>  Normal:  Inversion  #>  Sample:  Rejection  #>   #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] Matrix_1.7-0                patchwork_1.2.0             #>  [3] ggplot2_3.5.1               SingleCellExperiment_1.26.0 #>  [5] SummarizedExperiment_1.34.0 Biobase_2.64.0              #>  [7] GenomicRanges_1.56.1        GenomeInfoDb_1.40.1         #>  [9] IRanges_2.38.1              S4Vectors_0.42.1            #> [11] BiocGenerics_0.50.0         MatrixGenerics_1.16.0       #> [13] matrixStats_1.3.0           Seurat_5.1.0                #> [15] SeuratObject_5.0.2          sp_2.1-4                    #> [17] ClusterDE_0.99.3            BiocStyle_2.32.1            #>  #> loaded via a namespace (and not attached): #>   [1] RcppAnnoy_0.0.22        splines_4.4.1           later_1.3.2             #>   [4] tibble_3.2.1            polyclip_1.10-7         fastDummies_1.7.3       #>   [7] lifecycle_1.0.4         globals_0.16.3          lattice_0.22-6          #>  [10] MASS_7.3-60.2           magrittr_2.0.3          limma_3.60.4            #>  [13] plotly_4.10.4           sass_0.4.9              rmarkdown_2.27          #>  [16] jquerylib_0.1.4         yaml_2.3.10             httpuv_1.6.15           #>  [19] sctransform_0.4.1       spam_2.10-0             spatstat.sparse_3.1-0   #>  [22] reticulate_1.38.0       cowplot_1.1.3           pbapply_1.7-2           #>  [25] RColorBrewer_1.1-3      abind_1.4-5             zlibbioc_1.50.0         #>  [28] Rtsne_0.17              purrr_1.0.2             kde1d_1.0.7             #>  [31] GenomeInfoDbData_1.2.12 ggrepel_0.9.5           irlba_2.3.5.1           #>  [34] listenv_0.9.1           spatstat.utils_3.0-5    goftest_1.2-3           #>  [37] RSpectra_0.16-2         spatstat.random_3.3-1   fitdistrplus_1.2-1      #>  [40] parallelly_1.38.0       pkgdown_2.1.0           leiden_0.4.3.1          #>  [43] codetools_0.2-20        DelayedArray_0.30.1     tidyselect_1.2.1        #>  [46] UCSC.utils_1.0.0        farver_2.1.2            randtoolbox_2.0.4       #>  [49] spatstat.explore_3.3-1  jsonlite_1.8.8          progressr_0.14.0        #>  [52] ggridges_0.5.6          survival_3.6-4          systemfonts_1.1.0       #>  [55] tools_4.4.1             ragg_1.3.2              ica_1.0-3               #>  [58] Rcpp_1.0.13             glue_1.7.0              gridExtra_2.3           #>  [61] SparseArray_1.4.8       xfun_0.46               mvnfast_0.2.8           #>  [64] dplyr_1.1.4             withr_3.0.1             BiocManager_1.30.23     #>  [67] fastmap_1.2.0           fansi_1.0.6             digest_0.6.36           #>  [70] R6_2.5.1                mime_0.12               textshaping_0.4.0       #>  [73] colorspace_2.1-1        scattermore_1.2         tensor_1.5              #>  [76] spatstat.data_3.1-2     utf8_1.2.4              tidyr_1.3.1             #>  [79] generics_0.1.3          data.table_1.15.4       httr_1.4.7              #>  [82] htmlwidgets_1.6.4       S4Arrays_1.4.1          rngWELL_0.10-9          #>  [85] uwot_0.2.2              pkgconfig_2.0.3         gtable_0.3.5            #>  [88] lmtest_0.9-40           XVector_0.44.0          htmltools_0.5.8.1       #>  [91] dotCall64_1.1-1         bookdown_0.40           scales_1.3.0            #>  [94] png_0.1-8               spatstat.univar_3.0-0   knitr_1.48              #>  [97] reshape2_1.4.4          nlme_3.1-164            cachem_1.1.0            #> [100] zoo_1.8-12              stringr_1.5.1           KernSmooth_2.23-24      #> [103] parallel_4.4.1          miniUI_0.1.1.1          desc_1.4.3              #> [106] pillar_1.9.0            grid_4.4.1              vctrs_0.6.5             #> [109] RANN_2.6.1              promises_1.3.0          xtable_1.8-4            #> [112] cluster_2.1.6           evaluate_0.24.0         cli_3.6.3               #> [115] compiler_4.4.1          rlang_1.1.4             crayon_1.5.3            #> [118] future.apply_1.11.2     labeling_0.4.3          plyr_1.8.9              #> [121] fs_1.6.4                stringi_1.8.4           viridisLite_0.4.2       #> [124] deldir_2.0-4            assertthat_0.2.1        rvinecopulib_0.6.3.1.1  #> [127] munsell_0.5.1           lazyeval_0.2.2          coop_0.6-3              #> [130] spatstat.geom_3.3-2     RcppHNSW_0.6.0          future_1.34.0           #> [133] statmod_1.5.0           shiny_1.9.1             highr_0.11              #> [136] ROCR_1.0-11             igraph_2.0.3            bslib_0.8.0             #> [139] ape_5.8"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-cellline.html","id":"download-data","dir":"Articles","previous_headings":"","what":"Download data","title":"Perform ClusterDE on a cell line dataset","text":"download cell line data set H2228. original data Tian et al., Nature Methods 2019 gold standard benchmarking accuracy clustering. Since data pure cell line, cell types, , course, cell type DE genes. Note: mean variations within one cell line; course , e.g., cell cycle, total UMI, etc. However, variations represent discrete cell groups essentially means using obtained clusters explain variation.","code":"sce <- readRDS(url(\"https://figshare.com/ndownloader/files/41395260\")) cellline <- Seurat::as.Seurat(sce) #> Warning: Keys should be one or more alphanumeric characters followed by an #> underscore, setting key from PC to PC_"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-cellline.html","id":"run-the-regular-seurat-pipeline","dir":"Articles","previous_headings":"","what":"Run the regular Seurat pipeline","title":"Perform ClusterDE on a cell line dataset","text":"perform default Seurat clustering. Please note ClusterDE designed 1 vs 1 comparison; therefore, set resolution 0.2 obtain two clusters illustration purpose. UMAP, two clusters seem dubious. Although expect existence cell types, perform Seurat DE test two clusters, get > 1000 genes FDR < 0.05. means double dipping introduces huge number discoveries.","code":"RNGkind(\"L'Ecuyer-CMRG\") set.seed(123) cellline <- UpdateSeuratObject(cellline) ## Avoid errors #> Validating object structure #> Updating object slots #> Ensuring keys are in the proper structure #> Updating matrix keys for DimReduc 'PCA' #> Updating matrix keys for DimReduc 'UMAP' #> Ensuring keys are in the proper structure #> Ensuring feature names don't have underscores or pipes #> Updating slots in originalexp #> Updating slots in PCA #> Updating slots in UMAP #> Setting UMAP DimReduc to global #> Validating object structure for Assay 'originalexp' #> Validating object structure for DimReduc 'PCA' #> Validating object structure for DimReduc 'UMAP' #> Object representation is consistent with the most current Seurat version cellline <- NormalizeData(object = cellline) cellline <- FindVariableFeatures(object = cellline) cellline <- ScaleData(object = cellline) #> Centering and scaling data matrix cellline <- RunPCA(object = cellline) #> PC_ 1  #> Positive:  RPS14, RPL18AP3, RPL36, RPS23, RPL28, LRRC75A-AS1, AC079250.1, FTH1, ZFAS1, EEF2  #>     RPL7P9, RPL13A, RPS3AP26, EEF1A1P13, RPS16, RPS23P8, RPL13AP5, RPL29, FTH1P10, RPL13AP25  #>     SNHG5, FTH1P8, RPL4, RPS3AP6, AC064799.1, C6orf48, FTH1P7, C1orf56, RPL7AP6, TMSB4X  #> Negative:  PSMB2, PSMA7, U2AF1, NUDC, RBM8A, CALM1, BUB3, CLIC1, U2AF1L5, XRCC5  #>     VPS29, RBM8B, CACYBP, RPA3, SSBP1, PSMC5, MRPL47, PSMD8, BRIX1, CNIH4  #>     PCMT1, PSMD13, CYC1, PRDX2, SEPT7, S100A11, VDAC3, PSME2P2, ZWINT, HMGB1  #> PC_ 2  #> Positive:  NACA, RPL7AP6, SKP1, UBA52, BTF3, SSR2, RPL7A, ARPC3, RPL9P9, PPIA  #>     PSMD4, EIF1, RPL10, LGALS3BP, RPL10P16, SNRPB2, RPL10P9, S100A11, PPIB, ANXA5  #>     EEF2, PSME1, SSBP1, SSR4, RPL7P9, COPE, BSG, MGST1, VPS28, COPS6  #> Negative:  SIVA1, HNRNPAB, RPL39L, DEK, CDCA5, TMPO, FAM111A, ASF1B, CENPK, ESCO2  #>     BRCA1, H2AFV, RAD51AP1, MT-RNR2, ORC6, CENPX, SNRNP25, FBXO5, RRM1, DIAPH3  #>     USP1, CDCA4, TMEM106C, PGP, LSM4, C21orf58, CENPN, BRI3BP, SGO1, CHAF1A  #> PC_ 3  #> Positive:  RPL13AP5, RPL13AP25, AC024293.1, RPL29, RPSAP19, RPS5, RPL18, RPS3AP26, RPS3AP6, RPL15  #>     RPL28, DRAP1, RPS11, RPL9P9, RPL13AP7, RPS19, DCBLD2, FXYD5, FEN1, SLBP  #>     RPS15, COTL1, RPSA, FLNA, RPL7AP6, RPL36, C1orf21, CPA4, ORC6, RPS16  #> Negative:  SMIM22, TSPAN13, ST14, PERP, CRB3, MT-CO1, SERINC2, ATP1B1, CDH1, F11R  #>     B2M, MT-RNR2, SPINT1, NMB, PLA2G16, SPDEF, CD55, ADGRF1, TSPAN1, LIMA1  #>     ERBB3, ERO1A, ASS1, CDA, ALCAM, SYNGR2, MT-CO2, CDH3, C3, LSR  #> PC_ 4  #> Positive:  IFNGR1, NAMPT, NAP1L1, CPD, LMAN1, CALR, ITGA2, NAMPTP1, ITM2B, RRM1  #>     C3, RHOBTB3, CTHRC1, EEF2, HSD17B11, C1S, IFI16, SMC2, CPE, EPHX1  #>     DST, HLA-DMB, NUCB2, MT-ND6, TMEM45A, BRCA1, CDK5RAP2, HINT1, C1R, FAM111A  #> Negative:  S100A16, TMA7, TIMM8B, PFN1, SLIRP, GPX1, LAMC2, POLR2L, MRPL52, RPS19  #>     CDH1, TOMM40, ATP5MD, HSPE1, NAA10, GPX1P1, RPS16, MRPL12, MCRIP2, PDCD5  #>     RPL18, PLEC, S100A13, RPL36AL, LAD1, MGLL, BOLA2B, MISP, MRPL36, SEC61G  #> PC_ 5  #> Positive:  HINT1, COX5B, TXN, SOD1, NDUFA4, NDUFS6, ATP5PO, ATP5MC3, S100A10, ATP6V0E1  #>     CYB5A, SLIRP, NDUFB4, ATP5MC1, HSPE1, TXNP6, POMP, POLR2L, RPS14, HSPE1P4  #>     RPS15, CBR1, NDUFB3, HSPE1P3, ATP5PD, COX7B, ADGRF1, PSMB9, AC079250.1, NDUFAB1  #> Negative:  BTG1, PPP1R15A, EIF1, JUN, CEBPG, H3F3B, TMEM132A, C6orf48, HIST2H4B, SGK1  #>     KPNA4, PMEPA1, KLF6, CDKN1A, WARS, PEA15, GARS, MAP1LC3B, SNHG12, SERTAD1  #>     LAMC2, EPB41L4A-AS1, NAP1L1, SNHG5, KLF10, SLC7A5, KIF5B, ATP2B1, EIF5, ABL2 #> Warning: Key 'PC_' taken, using 'pca_' instead cellline <- FindNeighbors(object = cellline) #> Computing nearest neighbor graph #> Computing SNN cellline <- FindClusters(object = cellline, resolution = 0.2) #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 758 #> Number of edges: 24895 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.8257 #> Number of communities: 2 #> Elapsed time: 0 seconds cellline <- RunUMAP(object = cellline, dims = 1:10) #> Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric #> To use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation' #> This message will be shown once per session #> 18:32:28 UMAP embedding parameters a = 0.9922 b = 1.112 #> 18:32:28 Read 758 rows and found 10 numeric columns #> 18:32:28 Using Annoy for neighbor search, n_neighbors = 30 #> 18:32:28 Building Annoy index with metric = cosine, n_trees = 50 #> 0%   10   20   30   40   50   60   70   80   90   100% #> [----|----|----|----|----|----|----|----|----|----| #> **************************************************| #> 18:32:28 Writing NN index file to temp file /tmp/RtmpqycZA2/file1859553a02a7 #> 18:32:28 Searching Annoy index using 1 thread, search_k = 3000 #> 18:32:28 Annoy recall = 100% #> 18:32:28 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30 #> 18:32:30 Initializing from normalized Laplacian + noise (using RSpectra) #> 18:32:30 Commencing optimization for 500 epochs, with 27914 positive edges #> 18:32:31 Optimization finished DimPlot(object = cellline, reduction = \"umap\") + ggtitle(\"Clustering result\") original_markers <- FindMarkers(cellline,                                  ident.1 = 0,                                  ident.2 = 1,                                  min.pct = 0,                                  logfc.threshold = 0) #> For a (much!) faster implementation of the Wilcoxon Rank Sum Test, #> (default method for FindMarkers) please install the presto package #> -------------------------------------------- #> install.packages('devtools') #> devtools::install_github('immunogenomics/presto') #> -------------------------------------------- #> After installation of presto, Seurat will automatically use the more  #> efficient implementation (no further action necessary). #> This message will be shown once per session print(sum(original_markers$p_val_adj < 0.05)) #> [1] 1023"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-cellline.html","id":"generate-synthetic-null-data","dir":"Articles","previous_headings":"","what":"Generate synthetic null data","title":"Perform ClusterDE on a cell line dataset","text":"first generate synthetic null data based target data (real data). can increase number cores speed . perform pipeline target data. Please note need two clusters , . straightforward clustering method predefined cluster numbers, e.g., K-means. louvain clustering used Seurat may manually adjust resolution parameter still get two clusters. perform DE test synthetic null data. extract p-values original data synthetic null data, use ClusterDE “compare” . discover DE genes. can also visualize distribution contrast scores (diff -log p-values real null). roughly symmetric around 0.","code":"count_mat <- GetAssayData(object = cellline, slot = \"counts\") #> Warning: The `slot` argument of `GetAssayData()` is deprecated as of SeuratObject 5.0.0. #> ℹ Please use the `layer` argument instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. set.seed(123) system.time(synthetic_null <- ClusterDE::constructNull(count_mat, nCores = 2, fastVersion = TRUE, family = \"nb\", ifSparse = FALSE)) #> 1 genes have no more than 2 non-zero values; ignore fitting and return all 0s. #> 98.5% of genes are used in correlation modelling. #>    user  system elapsed  #> 114.478  64.780  53.208 cellline_null <- CreateSeuratObject(counts = synthetic_null)  set.seed(123) cellline_null <- NormalizeData(object = cellline_null) #> Normalizing layer: counts cellline_null <- FindVariableFeatures(object = cellline_null) #> Finding variable features for layer counts cellline_null <- ScaleData(object = cellline_null) #> Centering and scaling data matrix cellline_null <- RunPCA(object = cellline_null) #> PC_ 1  #> Positive:  NUCKS1, CALM1, CACYBP, PSMB2, SOD1, NDUFAB1, ATP5PO, XRCC5, VPS29, ATP5PD  #>     PSMA7, RPA3, U2AF1, HMGB1, BUB3, RBM8A, NUDC, CNIH4, PSMC5, MRPL47  #>     RANBP1, CCDC34, SRSF7, SLIRP, ATP5MC3, CYC1, SEPT7, MRPL51, NDUFA8, SNRPF  #> Negative:  RPL28, RPL13AP25, RPL13AP5, LRRC75A-AS1, RPS11, RPL13A, EEF2, RPS16, ZFAS1, RPL7P9  #>     EEF1A1P13, RPL10P16, RPL10, RPS3AP6, RPL7AP6, RPL9P9, RPS4XP11, RPL13AP7, RPS5, SNHG5  #>     RPL10P9, FTH1, TMSB4X, RPL4, RPS23P8, RPS3, RPS15, EPB41L4A-AS1, UGCG, FTH1P8  #> PC_ 2  #> Positive:  NACA, SKP1, SSR2, PSMD4, BTF3, RPL7AP6, LGALS3BP, RPL7A, ARPC3, UBA52  #>     RPL9P9, BSG, ADH5, RPL10, ANXA5, EIF1, CTSD, SNRPB2, MGST1, PPIB  #>     RPL10P16, SSBP1, PSME1, RPL10P9, EIF3M, SQSTM1, EEF2, RNH1, PPA1, ERP29  #> Negative:  SIVA1, CDCA5, RPL39L, TMPO, CENPX, CDCA4, HNRNPAB, DEK, CENPK, H2AFV  #>     SAC3D1, CKLF, ASF1B, SUZ12, USP1, ESCO2, FAM111A, SHCBP1, CENPN, ORC6  #>     FBXO5, BRCA1, ZWINT, LSM4, RAD51AP1, MT-CO2, WDR34, CHAF1A, DNAJC9, CMC2  #> PC_ 3  #> Positive:  RPSAP19, RPL13AP5, RPL18, RPL13AP25, RPL15, RPS11, RPL13AP7, RPS5, RPS19, CFL1  #>     RPSA, FXYD5, FBL, RPL28, SLBP, PDCD5, RPS3AP6, RPS16, RPL9P9, PEBP1  #>     DRAP1, PFN1, AP2S1, NME1, NAA10, RPS15, FLNA, DNMT1, COTL1, UBA52  #> Negative:  MT-CO1, MTCO1P12, TSPAN13, B2M, ADGRF1, ST14, MT-CO2, CPD, SERINC2, LIPH  #>     SMIM22, C3, GOLGB1, NMB, PERP, F11R, ASS1, LIMA1, ATP1B1, SELENBP1  #>     MT-CYB, TAX1BP1, LGMN, PPIC, GPX3, SPINT1, HLA-E, SDC4, TNFAIP2, CCDC186  #> PC_ 4  #> Positive:  SLIRP, S100A16, POLR2L, ATP5MC3, RPL36AL, HSPE1, NDUFS6, TRMT112, S100A13, HSPE1P4  #>     COX7B, HSPE1P3, ATP5MC1, SNRPG, COX5B, PFN1, MPC1, MRPL12, SNRPF, MCRIP2  #>     BOLA2B, DYNLL1, NAA10, CHCHD10, PDCD5, NDUFB10, SEC61G, CYC1, MGLL, NDUFB3  #> Negative:  NAP1L1, NAMPT, RRM1, C1S, EZH2, IFNGR1, TARS, BRCA1, RFC4, ITGA2  #>     PSAP, RAD51AP1, ATF4, SYNE2, RMI1, CPD, EXOSC8, CEP57, GLA, FANCG  #>     GARS, HSD17B4, P4HB, SLC7A11, EEF1A1P13, IFI16, LRRC75A-AS1, CDCA5, NCOA7, MCM6  #> PC_ 5  #> Positive:  H3F3B, BTG1, CDCA8, KIF5B, CEP55, CDCA2, TROAP, C6orf48, RPL10P16, KIF20A  #>     UBALD2, KIF14, RPL10P9, RPL10, NEK2, KIF4A, ARHGAP11A, EIF1, MXD3, PRR11  #>     HMGB3, CKAP2L, AAK1, RAD21, HP1BP3, RACGAP1, RNF26, RPSAP19, AC084033.3, FOXM1  #> Negative:  S100A10, ATP6V0E1, TXN, ASPH, RMI2, SPTSSA, COX5B, MRPL17, NDUFB4, IFNGR1  #>     SOD1, PAQR4, THYN1, RFC4, CDC6, CDCA7, GCHFR, ATP5PO, MCM2, CASP4  #>     ATP5MC1, SLBP, FTH1, C9orf3, COTL1, FTH1P8, CARHSP1, ADGRF1, MCM3, RPA3 cellline_null <- FindNeighbors(object = cellline_null) #> Computing nearest neighbor graph #> Computing SNN cellline_null <- FindClusters(object = cellline_null, resolution = 0.3) #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 758 #> Number of edges: 29737 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.7327 #> Number of communities: 2 #> Elapsed time: 0 seconds cellline_null <- RunUMAP(object = cellline_null, dims = 1:10) #> 18:34:17 UMAP embedding parameters a = 0.9922 b = 1.112 #> 18:34:17 Read 758 rows and found 10 numeric columns #> 18:34:17 Using Annoy for neighbor search, n_neighbors = 30 #> 18:34:17 Building Annoy index with metric = cosine, n_trees = 50 #> 0%   10   20   30   40   50   60   70   80   90   100% #> [----|----|----|----|----|----|----|----|----|----| #> **************************************************| #> 18:34:17 Writing NN index file to temp file /tmp/RtmpqycZA2/file185951df402 #> 18:34:17 Searching Annoy index using 1 thread, search_k = 3000 #> 18:34:17 Annoy recall = 100% #> 18:34:18 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30 #> 18:34:19 Initializing from normalized Laplacian + noise (using RSpectra) #> 18:34:19 Commencing optimization for 500 epochs, with 28134 positive edges #> 18:34:20 Optimization finished DimPlot(object = cellline_null, reduction = \"umap\") null_markers <- FindMarkers(cellline_null,                              ident.1 = 0,                              ident.2 = 1,                              min.pct = 0,                              logfc.threshold = 0) original_pval <- original_markers$p_val names(original_pval) <- rownames(original_markers)  null_pval <- null_markers$p_val names(null_pval) <- rownames(null_markers)  res <- ClusterDE::callDE(original_pval, null_pval, nlogTrans = TRUE) cat(paste0(\"Number of DE gene is \", length(res$DEgenes))) #> Number of DE gene is 0 ggplot(data = res$summaryTable, aes(x = cs)) + geom_histogram(fill = \"white\", color = \"black\") + theme_bw() + ggtitle(\"Distribution of constrast scores\") #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`."},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-cellline.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Perform ClusterDE on a cell line dataset","text":"","code":"sessionInfo() #> R version 4.4.1 (2024-06-14) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.4 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> Random number generation: #>  RNG:     L'Ecuyer-CMRG  #>  Normal:  Inversion  #>  Sample:  Rejection  #>   #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] ggplot2_3.5.1               SingleCellExperiment_1.26.0 #>  [3] SummarizedExperiment_1.34.0 Biobase_2.64.0              #>  [5] GenomicRanges_1.56.1        GenomeInfoDb_1.40.1         #>  [7] IRanges_2.38.1              S4Vectors_0.42.1            #>  [9] BiocGenerics_0.50.0         MatrixGenerics_1.16.0       #> [11] matrixStats_1.3.0           Seurat_5.1.0                #> [13] SeuratObject_5.0.2          sp_2.1-4                    #> [15] ClusterDE_0.99.3            BiocStyle_2.32.1            #>  #> loaded via a namespace (and not attached): #>   [1] RcppAnnoy_0.0.22        splines_4.4.1           later_1.3.2             #>   [4] tibble_3.2.1            polyclip_1.10-7         fastDummies_1.7.3       #>   [7] lifecycle_1.0.4         globals_0.16.3          lattice_0.22-6          #>  [10] MASS_7.3-60.2           magrittr_2.0.3          limma_3.60.4            #>  [13] plotly_4.10.4           sass_0.4.9              rmarkdown_2.27          #>  [16] jquerylib_0.1.4         yaml_2.3.10             httpuv_1.6.15           #>  [19] sctransform_0.4.1       spam_2.10-0             spatstat.sparse_3.1-0   #>  [22] reticulate_1.38.0       cowplot_1.1.3           pbapply_1.7-2           #>  [25] RColorBrewer_1.1-3      abind_1.4-5             zlibbioc_1.50.0         #>  [28] Rtsne_0.17              purrr_1.0.2             kde1d_1.0.7             #>  [31] GenomeInfoDbData_1.2.12 ggrepel_0.9.5           irlba_2.3.5.1           #>  [34] listenv_0.9.1           spatstat.utils_3.0-5    goftest_1.2-3           #>  [37] RSpectra_0.16-2         spatstat.random_3.3-1   fitdistrplus_1.2-1      #>  [40] parallelly_1.38.0       pkgdown_2.1.0           leiden_0.4.3.1          #>  [43] codetools_0.2-20        DelayedArray_0.30.1     tidyselect_1.2.1        #>  [46] UCSC.utils_1.0.0        farver_2.1.2            randtoolbox_2.0.4       #>  [49] spatstat.explore_3.3-1  jsonlite_1.8.8          progressr_0.14.0        #>  [52] ggridges_0.5.6          survival_3.6-4          systemfonts_1.1.0       #>  [55] tools_4.4.1             ragg_1.3.2              ica_1.0-3               #>  [58] Rcpp_1.0.13             glue_1.7.0              gridExtra_2.3           #>  [61] SparseArray_1.4.8       xfun_0.46               mvnfast_0.2.8           #>  [64] dplyr_1.1.4             withr_3.0.1             BiocManager_1.30.23     #>  [67] fastmap_1.2.0           fansi_1.0.6             digest_0.6.36           #>  [70] R6_2.5.1                mime_0.12               textshaping_0.4.0       #>  [73] colorspace_2.1-1        scattermore_1.2         tensor_1.5              #>  [76] spatstat.data_3.1-2     utf8_1.2.4              tidyr_1.3.1             #>  [79] generics_0.1.3          data.table_1.15.4       httr_1.4.7              #>  [82] htmlwidgets_1.6.4       S4Arrays_1.4.1          rngWELL_0.10-9          #>  [85] uwot_0.2.2              pkgconfig_2.0.3         gtable_0.3.5            #>  [88] lmtest_0.9-40           XVector_0.44.0          htmltools_0.5.8.1       #>  [91] dotCall64_1.1-1         bookdown_0.40           scales_1.3.0            #>  [94] png_0.1-8               spatstat.univar_3.0-0   knitr_1.48              #>  [97] reshape2_1.4.4          nlme_3.1-164            cachem_1.1.0            #> [100] zoo_1.8-12              stringr_1.5.1           KernSmooth_2.23-24      #> [103] parallel_4.4.1          miniUI_0.1.1.1          desc_1.4.3              #> [106] pillar_1.9.0            grid_4.4.1              vctrs_0.6.5             #> [109] RANN_2.6.1              promises_1.3.0          xtable_1.8-4            #> [112] cluster_2.1.6           evaluate_0.24.0         cli_3.6.3               #> [115] compiler_4.4.1          rlang_1.1.4             crayon_1.5.3            #> [118] future.apply_1.11.2     labeling_0.4.3          plyr_1.8.9              #> [121] fs_1.6.4                stringi_1.8.4           viridisLite_0.4.2       #> [124] deldir_2.0-4            assertthat_0.2.1        rvinecopulib_0.6.3.1.1  #> [127] munsell_0.5.1           lazyeval_0.2.2          coop_0.6-3              #> [130] spatstat.geom_3.3-2     Matrix_1.7-0            RcppHNSW_0.6.0          #> [133] patchwork_1.2.0         future_1.34.0           statmod_1.5.0           #> [136] shiny_1.9.1             highr_0.11              ROCR_1.0-11             #> [139] igraph_2.0.3            bslib_0.8.0"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-onedomain.html","id":"download-data","dir":"Articles","previous_headings":"","what":"Download data","title":"Perform ClusterDE on a single-domain spatial dataset","text":"selected layer 5 151673 slice LIBD Human Dorsolateral Prefrontal Cortex (DLPFC) dataset, downloaded spatialLIBD R package. Since data contains one domain, domains marker genes.  Visualize real data.","code":"## Download the spot-level data spe <- fetch_data(type = \"spe\") #> adding rname 'https://www.dropbox.com/s/f4wcvtdq428y73p/Human_DLPFC_Visium_processedData_sce_scran_spatialLIBD.Rdata?dl=1' #> 2024-08-02 18:35:45.017086 loading file /home/runner/.cache/R/BiocFileCache/18ed545ef88_Human_DLPFC_Visium_processedData_sce_scran_spatialLIBD.Rdata%3Fdl%3D1  ###select the Layer5 in the slice 151673 sub_151673 <- spe[, spe$sample_id == \"151673\"] index <- sub_151673$spatialLIBD == \"L5\" index[which(is.na(index))]=\"NAN\" sub_151673 <- sub_151673[, index==\"TRUE\"] print(sub_151673) #> class: SpatialExperiment  #> dim: 33538 673  #> metadata(0): #> assays(2): counts logcounts #> rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 #>   ENSG00000268674 #> rowData names(9): source type ... gene_search is_top_hvg #> colnames(673): AAACAGCTTTCAGAAG-1 AAACCTCATGAAGTTG-1 ... #>   TTGTTCAGTGTGCTAC-1 TTGTTGTGTGTCAAGA-1 #> colData names(69): sample_id Cluster ... array_row array_col #> reducedDimNames(6): PCA TSNE_perplexity50 ... TSNE_perplexity80 #>   UMAP_neighbors15 #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres #> imgData names(4): sample_id image_id data scaleFactor  #delete the genes that express rate less than 20% data <- sub_151673@assays@data$counts zero_expre_rate <- apply(data,1,function(x){   zero_true<-x==0   zero_num<-length(which(zero_true==TRUE))/dim(data)[2]   return(zero_num) }) zero_expre_gene_idx <- which(zero_expre_rate<0.8) print(paste0(\"the number of gene with zero expression rate: \",sum(zero_expre_rate==1),sep=\"\")) #> [1] \"the number of gene with zero expression rate: 14846\" sub_151673 <- sub_151673[zero_expre_gene_idx,] print(paste0(\"the size of data: \",dim(sub_151673)[1],\"*\",dim(sub_151673)[2],sep=\"\")) #> [1] \"the size of data: 3970*673\"  ###construct the SingleCellExperiment object real_sce <- SingleCellExperiment(list(counts=sub_151673@assays@data$counts)) ###add colData information of singlecellexperiment real_sce$spatial1 <- sub_151673@int_colData@listData$spatialCoords[,2] real_sce$spatial2 <- sub_151673@int_colData@listData$spatialCoords[,1] real_sce$cell_type <- sub_151673@colData$spatialLIBD ###visualize the real spatial domains real_sce_domains <- data.frame(Xaxis=real_sce$spatial1,Yaxis=real_sce$spatial2,Domain=real_sce$cell_type) ggplot(real_sce_domains, aes(x = Xaxis, y = Yaxis, col =Domain)) + geom_point(size=1.0) +   ggtitle(\"Manual annotation \\n (The layer5 in the slice 151673)\") +    theme(plot.title = element_text(size=10,hjust=0.5),         panel.grid=element_blank(),         panel.background = element_rect(fill = \"gray90\"),         panel.border = element_rect(color = \"black\", fill = NA, size = 0.6),         axis.title.x = element_blank(),         axis.title.y = element_blank(),         axis.ticks.x = element_blank(),         axis.ticks.y = element_blank(),         axis.text.x = element_blank(),         axis.text.y = element_blank()) + scale_color_manual(values = c(\"#5791cc\")) #> Warning: The `size` argument of `element_rect()` is deprecated as of ggplot2 3.4.0. #> ℹ Please use the `linewidth` argument instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated."},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-onedomain.html","id":"run-the-bayesspace-seurat-pipeline","dir":"Articles","previous_headings":"","what":"Run the BayesSpace + Seurat pipeline","title":"Perform ClusterDE on a single-domain spatial dataset","text":"Firstly, employed BayesSpace spatial clustering. Please note ClusterDE designed 1 vs 1 comparison; therefore, obtain two spatial clusters illustration purpose.  Visualize spatial clustering results based real data , used common DE method (Wilcoxon Rank Sum Test) identify domain marker genes two spatial clusters.","code":"###construct the input of BayesSpace based on real dataset #the input of BayesSpace is sce object real_sce_clu <- SingleCellExperiment(list(counts=real_sce@assays@data$counts)) # add colData information of singlecellexperiment real_sce_clu$row <- real_sce$spatial1 real_sce_clu$col <- real_sce$spatial2 ## log-normalize the count data set.seed(102) real_sce_clu <- spatialPreprocess(real_sce_clu, platform=\"ST\", n.PCs=7,log.normalize=TRUE) #clustering with BayesSpace set.seed(149) real_sce_clu <- spatialCluster(real_sce_clu, q=2, platform=\"ST\", d=7,                                init.method=\"mclust\", model=\"t\", gamma=2,                                nrep=1000, burn.in=100,                                save.chain=TRUE) #> Neighbors were identified for 0 out of 673 spots. #> Fitting model... #> Calculating labels using iterations 100 through 1000. #visualize the spatial cluster real_sce_spatial_clu <- data.frame(Xaxis=real_sce_clu$row,Yaxis=real_sce_clu$col,Clusters=as.character(real_sce_clu$spatial.cluster)) ggplot(real_sce_spatial_clu, aes(x = Xaxis, y = Yaxis, col =Clusters)) + geom_point(size=1.0) +   ggtitle(\"Real data \\n (spatial clusters detected by BayesSpace)\") +    theme(plot.title = element_text(size=10,hjust=0.5),         panel.grid = element_blank(),         panel.background = element_rect(fill = \"gray90\"),         panel.border = element_rect(color = \"black\", fill = NA, size = 0.6),         axis.title.x = element_blank(),         axis.title.y = element_blank(),         axis.ticks.x = element_blank(),         axis.ticks.y = element_blank(),         axis.text.x = element_blank(),         axis.text.y = element_blank()) + scale_color_manual(values = c(\"#e87d72\",\"#54bcc2\")) #Identify domain marker genes in the real dataset based on the BayesSpace clustering result, follow Seurat tutorial #create Seurat object real_count_dataset <- real_sce@assays@data$counts real_seurat <- CreateSeuratObject(counts = real_count_dataset, project = \"real_seurat\", min.cells = 0, min.features = 0) real_seurat[[\"percent.mt\"]] <- PercentageFeatureSet(real_seurat, pattern = \"^MT-\") real_seurat <- NormalizeData(real_seurat, normalization.method = \"LogNormalize\", scale.factor = 10000) #> Normalizing layer: counts real_seurat <- ScaleData(real_seurat, features = rownames(real_seurat)) #> Centering and scaling data matrix real_ct <-real_sce_clu$spatial.cluster names(real_ct) <- colnames(real_sce) real_seurat[[\"cell_type\"]] <- real_ct Idents(real_seurat) <- \"cell_type\" #Then we follow seurat tutorial to conduct DE analysis real_markers <- FindMarkers(object = real_seurat, ident.1 = unique(real_ct)[1], ident.2 =  unique(real_ct)[2], test.use = \"wilcox\", logfc.threshold = 0, min.pct = 0, min.cells.feature = 1, min.cells.group = 1) #> For a (much!) faster implementation of the Wilcoxon Rank Sum Test, #> (default method for FindMarkers) please install the presto package #> -------------------------------------------- #> install.packages('devtools') #> devtools::install_github('immunogenomics/presto') #> -------------------------------------------- #> After installation of presto, Seurat will automatically use the more  #> efficient implementation (no further action necessary). #> This message will be shown once per session real_pvals <- real_markers[rownames(real_seurat),\"p_val\"] names(real_pvals) <- rownames(real_seurat)"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-onedomain.html","id":"generate-synthetic-null-data","dir":"Articles","previous_headings":"","what":"Generate synthetic null data","title":"Perform ClusterDE on a single-domain spatial dataset","text":"first generate synthetic null data based target data (real data). can increase number cores speed using parameter “nCores”. perform pipeline target data. Please note need two spatial clusters , .  Visualize spatial clustering results based synthetic null data. Perform common DE method (Wilcoxon Rank Sum Test) synthetic null data extract p-values target data synthetic null data, use ClusterDE “compare” . discover DE genes. can also visualize distribution contrast scores (diff -log p-values real null). roughly symmetric around 0.","code":"###generate synthetic null data count_mat <- real_sce@assays@data$counts location_mat <- data.frame(X=real_sce$spatial1,Y=real_sce$spatial2) system.time(null_onedomain_dataset <- ClusterDE::constructNull(mat=count_mat,                                                    family = \"nb\",                                                    extraInfo=location_mat,                                                    formula = \"s(X, Y, bs = 'gp', k= 4)\",                                                    nCores = 2)) #> 100% of genes are used in correlation modelling. #>    user  system elapsed  #>  50.206  35.324  24.165 ###construct the input of BayesSpace based on null dataset###### null_sce <- SingleCellExperiment(list(counts =null_onedomain_dataset)) # add colData information of singlecellexperiment null_sce$row <- real_sce$spatial1 null_sce$col <- real_sce$spatial2 ## log-normalize the count data set.seed(102) null_sce<- spatialPreprocess(null_sce, platform=\"ST\", n.PCs=7,log.normalize=TRUE) #clustering with BayesSpace set.seed(149) null_sce <- spatialCluster(null_sce, q=2, platform=\"ST\", d=7,                            init.method=\"mclust\", model=\"t\", gamma=2,                            nrep=1000, burn.in=100,                            save.chain=TRUE) #> Neighbors were identified for 0 out of 673 spots. #> Fitting model... #> Calculating labels using iterations 100 through 1000. #visualize the spatial cluster null_spatial_clu=data.frame(Xaxis=null_sce$row,Yaxis=null_sce$col,Clusters=as.character(null_sce$spatial.cluster)) ggplot(null_spatial_clu, aes(x = Xaxis, y = Yaxis, col =Clusters))  + geom_point(size=1.0) +   ggtitle(\"Synthetic null data \\n (spatial clusters detected by BayesSpace)\") +    theme(plot.title = element_text(size=10,hjust=0.5),         panel.grid=element_blank(),         panel.background = element_rect(fill = \"gray90\"),         panel.border = element_rect(color = \"black\", fill = NA, size = 0.6),         axis.title.x = element_blank(),         axis.title.y = element_blank(),         axis.ticks.x = element_blank(),         axis.ticks.y = element_blank(),         axis.text.x = element_blank(),         axis.text.y = element_blank()) + scale_color_manual(values = c(\"#e87d72\",\"#54bcc2\")) #Identify domain marker genes in the synthetic null dataset based on the BayesSpace clustering result, follow Seurat tutorial #create Seurat object null_count_dataset= null_onedomain_dataset null_seurat <- CreateSeuratObject(counts = null_count_dataset, project = \"null_seurat\", min.cells = 0, min.features = 0) null_seurat[[\"percent.mt\"]] <- PercentageFeatureSet(null_seurat, pattern = \"^MT-\") null_seurat <- NormalizeData(null_seurat, normalization.method = \"LogNormalize\", scale.factor = 10000) #> Normalizing layer: counts null_seurat <- ScaleData(null_seurat, features = rownames(null_seurat)) #> Centering and scaling data matrix null_ct <- null_sce$spatial.cluster names(null_ct) <- colnames(null_sce) null_seurat[[\"cell_type\"]] <- null_ct Idents(null_seurat) <- \"cell_type\" #Then we follow seurat tutorial to conduct DE analysis null_markers <- FindMarkers(object = null_seurat, ident.1 = unique(null_ct)[1], ident.2 =  unique(null_ct)[2], test.use = \"wilcox\",logfc.threshold = 0, min.pct = 0, min.cells.feature = 1, min.cells.group = 1) null_pvals <- null_markers[rownames(null_seurat),\"p_val\"] names(null_pvals) <- rownames(null_seurat) ##run clusterDE to find real marker genes ###you can set the value of FDR, the default value is 0.05 res <- ClusterDE::callDE(real_pvals, null_pvals, nlogTrans = TRUE) print(paste0(\"The number of domain marker genes is: \",length(res$DEgenes),sep=\"\")) #> [1] \"The number of domain marker genes is: 0\" ggplot(data = res$summaryTable, aes(x = cs)) + geom_histogram(fill = \"white\", color = \"black\") + theme_bw() + ggtitle(\"Distribution of constrast scores\") #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`."},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-onedomain.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Perform ClusterDE on a single-domain spatial dataset","text":"","code":"sessionInfo() #> R version 4.4.1 (2024-06-14) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.4 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] scales_1.3.0                dplyr_1.1.4                 #>  [3] BayesSpace_1.14.0           ClusterDE_0.99.3            #>  [5] ggplot2_3.5.1               spatialLIBD_1.16.2          #>  [7] SpatialExperiment_1.14.0    SingleCellExperiment_1.26.0 #>  [9] SummarizedExperiment_1.34.0 Biobase_2.64.0              #> [11] GenomicRanges_1.56.1        GenomeInfoDb_1.40.1         #> [13] IRanges_2.38.1              S4Vectors_0.42.1            #> [15] BiocGenerics_0.50.0         MatrixGenerics_1.16.0       #> [17] matrixStats_1.3.0           Seurat_5.1.0                #> [19] SeuratObject_5.0.2          sp_2.1-4                    #> [21] BiocStyle_2.32.1            #>  #> loaded via a namespace (and not attached): #>   [1] DirichletReg_0.7-1        goftest_1.2-3             #>   [3] DT_0.33                   Biostrings_2.72.1         #>   [5] vctrs_0.6.5               spatstat.random_3.3-1     #>   [7] digest_0.6.36             png_0.1-8                 #>   [9] ggrepel_0.9.5             deldir_2.0-4              #>  [11] parallelly_1.38.0         magick_2.8.4              #>  [13] MASS_7.3-60.2             pkgdown_2.1.0             #>  [15] reshape2_1.4.4            httpuv_1.6.15             #>  [17] foreach_1.5.2             withr_3.0.1               #>  [19] xfun_0.46                 survival_3.6-4            #>  [21] memoise_2.0.1             benchmarkme_1.0.8         #>  [23] ggbeeswarm_0.7.2          systemfonts_1.1.0         #>  [25] ragg_1.3.2                zoo_1.8-12                #>  [27] pbapply_1.7-2             Formula_1.2-5             #>  [29] rematch2_2.1.2            KEGGREST_1.44.1           #>  [31] promises_1.3.0            httr_1.4.7                #>  [33] restfulr_0.0.15           randtoolbox_2.0.4         #>  [35] globals_0.16.3            fitdistrplus_1.2-1        #>  [37] rhdf5filters_1.16.0       rhdf5_2.48.0              #>  [39] UCSC.utils_1.0.0          miniUI_0.1.1.1            #>  [41] generics_0.1.3            curl_5.2.1                #>  [43] fields_16.2               zlibbioc_1.50.0           #>  [45] ScaledMatrix_1.12.0       polyclip_1.10-7           #>  [47] GenomeInfoDbData_1.2.12   ExperimentHub_2.12.0      #>  [49] SparseArray_1.4.8         golem_0.4.1               #>  [51] xtable_1.8-4              stringr_1.5.1             #>  [53] desc_1.4.3                doParallel_1.0.17         #>  [55] evaluate_0.24.0           S4Arrays_1.4.1            #>  [57] BiocFileCache_2.12.0      bookdown_0.40             #>  [59] irlba_2.3.5.1             colorspace_2.1-1          #>  [61] filelock_1.0.3            ROCR_1.0-11               #>  [63] reticulate_1.38.0         spatstat.data_3.1-2       #>  [65] shinyWidgets_0.8.6        magrittr_2.0.3            #>  [67] lmtest_0.9-40             later_1.3.2               #>  [69] viridis_0.6.5             lattice_0.22-6            #>  [71] spatstat.geom_3.3-2       future.apply_1.11.2       #>  [73] scattermore_1.2           XML_3.99-0.17             #>  [75] scuttle_1.14.0            cowplot_1.1.3             #>  [77] RcppAnnoy_0.0.22          pillar_1.9.0              #>  [79] nlme_3.1-164              iterators_1.0.14          #>  [81] compiler_4.4.1            beachmat_2.20.0           #>  [83] RSpectra_0.16-2           stringi_1.8.4             #>  [85] tensor_1.5                GenomicAlignments_1.40.0  #>  [87] plyr_1.8.9                crayon_1.5.3              #>  [89] abind_1.4-5               BiocIO_1.14.0             #>  [91] scater_1.32.1             locfit_1.5-9.10           #>  [93] bit_4.0.5                 sandwich_3.1-0            #>  [95] codetools_0.2-20          textshaping_0.4.0         #>  [97] BiocSingular_1.20.0       rngWELL_0.10-9            #>  [99] coop_0.6-3                bslib_0.8.0               #> [101] paletteer_1.6.0           plotly_4.10.4             #> [103] mime_0.12                 splines_4.4.1             #> [105] Rcpp_1.0.13               fastDummies_1.7.3         #> [107] dbplyr_2.5.0              sparseMatrixStats_1.16.0  #> [109] attempt_0.3.1             maxLik_1.5-2.1            #> [111] knitr_1.48                blob_1.2.4                #> [113] utf8_1.2.4                BiocVersion_3.19.1        #> [115] fs_1.6.4                  listenv_0.9.1             #> [117] DelayedMatrixStats_1.26.0 tibble_3.2.1              #> [119] Matrix_1.7-0              statmod_1.5.0             #> [121] pkgconfig_2.0.3           tools_4.4.1               #> [123] cachem_1.1.0              RSQLite_2.3.7             #> [125] viridisLite_0.4.2         DBI_1.2.3                 #> [127] fastmap_1.2.0             rmarkdown_2.27            #> [129] grid_4.4.1                ica_1.0-3                 #> [131] Rsamtools_2.20.0          AnnotationHub_3.12.0      #> [133] sass_0.4.9                patchwork_1.2.0           #> [135] coda_0.19-4.1             BiocManager_1.30.23       #> [137] dotCall64_1.1-1           RANN_2.6.1                #> [139] farver_2.1.2              yaml_2.3.10               #> [141] kde1d_1.0.7               rtracklayer_1.64.0        #> [143] cli_3.6.3                 purrr_1.0.2               #> [145] leiden_0.4.3.1            lifecycle_1.0.4           #> [147] uwot_0.2.2                bluster_1.14.0            #> [149] sessioninfo_1.2.2         BiocParallel_1.38.0       #> [151] gtable_0.3.5              rjson_0.2.21              #> [153] ggridges_0.5.6            progressr_0.14.0          #> [155] parallel_4.4.1            limma_3.60.4              #> [157] jsonlite_1.8.8            edgeR_4.2.1               #> [159] miscTools_0.6-28          RcppHNSW_0.6.0            #> [161] rvinecopulib_0.6.3.1.1    bitops_1.0-8              #> [163] benchmarkmeData_1.0.4     bit64_4.0.5               #> [165] assertthat_0.2.1          xgboost_1.7.8.1           #> [167] Rtsne_0.17                spatstat.utils_3.0-5      #> [169] BiocNeighbors_1.22.0      jquerylib_0.1.4           #> [171] highr_0.11                metapod_1.12.0            #> [173] config_0.3.2              dqrng_0.4.1               #> [175] spatstat.univar_3.0-0     lazyeval_0.2.2            #> [177] shiny_1.9.1               htmltools_0.5.8.1         #> [179] sctransform_0.4.1         rappdirs_0.3.3            #> [181] glue_1.7.0                spam_2.10-0               #> [183] XVector_0.44.0            RCurl_1.98-1.16           #> [185] scran_1.32.0              mclust_6.1.1              #> [187] mvnfast_0.2.8             gridExtra_2.3             #> [189] igraph_2.0.3              R6_2.5.1                  #> [191] tidyr_1.3.1               labeling_0.4.3            #> [193] cluster_2.1.6             Rhdf5lib_1.26.0           #> [195] DelayedArray_0.30.1       tidyselect_1.2.1          #> [197] vipor_0.4.7               maps_3.4.2                #> [199] AnnotationDbi_1.66.0      future_1.34.0             #> [201] rsvd_1.0.5                munsell_0.5.1             #> [203] KernSmooth_2.23-24        data.table_1.15.4         #> [205] htmlwidgets_1.6.4         RColorBrewer_1.1-3        #> [207] rlang_1.1.4               spatstat.sparse_3.1-0     #> [209] spatstat.explore_3.3-1    fansi_1.0.6               #> [211] beeswarm_0.4.0"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-twodomains.html","id":"download-data","dir":"Articles","previous_headings":"","what":"Download data","title":"Perform ClusterDE on a two-domain spatial dataset","text":"selected adjacent layer 6 WM 151673 slice LIBD Human Dorsolateral Prefrontal Cortex (DLPFC) dataset, downloaded spatialLIBD R package. removed genes expressed fewer 20% spots save computational time .","code":"### Download the spot-level data spe <- fetch_data(type = \"spe\") #> 2024-08-02 18:39:34.925389 loading file /home/runner/.cache/R/BiocFileCache/18ed545ef88_Human_DLPFC_Visium_processedData_sce_scran_spatialLIBD.Rdata%3Fdl%3D1  ### Select the Layer6 and WM domains in the slice \"151673\" sub_151673 <- spe[, spe$sample_id == \"151673\"] index <- sub_151673$spatialLIBD == \"L6\"|sub_151673$spatialLIBD == \"WM\" index[which(is.na(index))] <- \"NAN\" sub_151673 <- sub_151673[, index==\"TRUE\"] print(sub_151673) #> class: SpatialExperiment  #> dim: 33538 1205  #> metadata(0): #> assays(2): counts logcounts #> rownames(33538): ENSG00000243485 ENSG00000237613 ... ENSG00000277475 #>   ENSG00000268674 #> rowData names(9): source type ... gene_search is_top_hvg #> colnames(1205): AAACACCAATAACTGC-1 AAACAGGGTCTATATT-1 ... #>   TTGTTTCCATACAACT-1 TTGTTTGTATTACACG-1 #> colData names(69): sample_id Cluster ... array_row array_col #> reducedDimNames(6): PCA TSNE_perplexity50 ... TSNE_perplexity80 #>   UMAP_neighbors15 #> mainExpName: NULL #> altExpNames(0): #> spatialCoords names(2) : pxl_col_in_fullres pxl_row_in_fullres #> imgData names(4): sample_id image_id data scaleFactor  # Delete the genes that express rate less than 20% data <- sub_151673@assays@data$counts zero_expre_rate <- apply(data,1,function(x){   zero_true<-x==0   zero_num<-length(which(zero_true==TRUE))/dim(data)[2]   return(zero_num) }) zero_expre_gene_idx <- which(zero_expre_rate<0.8) sub_151673 <- sub_151673[zero_expre_gene_idx,] cat(paste0(\"The size of data: \",dim(sub_151673)[1],\"*\",dim(sub_151673)[2],sep=\"\")) #> The size of data: 2801*1205  ###construct the SingleCellExperiment object real_sce <- SingleCellExperiment(list(counts=sub_151673@assays@data$counts)) ###add colData information of singlecellexperiment real_sce$spatial1 <- sub_151673@int_colData@listData$spatialCoords[,2] real_sce$spatial2 <- sub_151673@int_colData@listData$spatialCoords[,1] real_sce$cell_type <- sub_151673@colData$spatialLIBD ###visualize the real spatial domains real_sce_domains <- data.frame(Xaxis=real_sce$spatial1,Yaxis=real_sce$spatial2,Domains=real_sce$cell_type) ggplot(real_sce_domains, aes(x = Xaxis, y = Yaxis, col =Domains)) + geom_point(size=1.0) + coord_equal() +   ggtitle(\"Manual annotation \\n (The layer6 and WM in the slice 151673)\") +    #scale_color_brewer(palette = \"Accent\") +   theme(plot.title = element_text(size=10,hjust=0.5),         panel.grid=element_blank(),         panel.background = element_rect(fill = \"gray90\"),         panel.border = element_rect(color = \"black\", fill = NA, linewidth = 0.6),         axis.title.x = element_blank(),         axis.title.y = element_blank(),         axis.ticks.x = element_blank(),         axis.ticks.y = element_blank(),         axis.text.x = element_blank(),         axis.text.y = element_blank()) + scale_color_manual(values = c(\"#5791cc\",\"#403f92\"))"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-twodomains.html","id":"run-the-bayesspace-seurat-pipeline","dir":"Articles","previous_headings":"","what":"Run the BayesSpace + Seurat pipeline","title":"Perform ClusterDE on a two-domain spatial dataset","text":"Firstly, employed BayesSpace spatial clustering. Please note ClusterDE designed 1 vs 1 comparison; therefore, obtain two spatial clusters illustration purpose.  , used common DE method (Wilcoxon Rank Sum Test) identify domain marker genes two spatial clusters.","code":"###construct the input of BayesSpace based on real dataset #the input of BayesSpace is sce object real_sce_clu <- SingleCellExperiment(list(counts=real_sce@assays@data$counts)) # add colData information of singlecellexperiment real_sce_clu$row <- real_sce$spatial1 real_sce_clu$col <- real_sce$spatial2 ## log-normalize the count data set.seed(102) real_sce_clu <- spatialPreprocess(real_sce_clu, platform=\"ST\", n.PCs=7,log.normalize=TRUE) #clustering with BayesSpace set.seed(149) real_sce_clu <- spatialCluster(real_sce_clu, q=2, platform=\"ST\", d=7,                                init.method=\"mclust\", model=\"t\", gamma=2,                                nrep=1000, burn.in=100,                                save.chain=TRUE) #> Neighbors were identified for 0 out of 1205 spots. #> Fitting model... #> You created a large dataset with compression and chunking. #> The chunk size is equal to the dataset dimensions. #> If you want to read subsets of the dataset, you should testsmaller chunk sizes to improve read times. #> You created a large dataset with compression and chunking. #> The chunk size is equal to the dataset dimensions. #> If you want to read subsets of the dataset, you should testsmaller chunk sizes to improve read times. #> Calculating labels using iterations 100 through 1000. #visualize the spatial cluster real_sce_spatial_clu <- data.frame(Xaxis=real_sce_clu$row,Yaxis=real_sce_clu$col,Clusters=as.character(real_sce_clu$spatial.cluster)) ggplot(real_sce_spatial_clu, aes(x = Xaxis, y = Yaxis, col =Clusters)) + geom_point(size=1.0) + coord_equal() +   ggtitle(\"Real data \\n (spatial clusters detected by BayesSpace)\") +    #scale_color_brewer(palette = \"Accent\") +   theme(plot.title = element_text(size=10,hjust=0.5),         panel.grid=element_blank(),         panel.background = element_rect(fill = \"gray90\"),         panel.border = element_rect(color = \"black\", fill = NA, size = 0.6),         axis.title.x = element_blank(),         axis.title.y = element_blank(),         axis.ticks.x = element_blank(),         axis.ticks.y = element_blank(),         axis.text.x = element_blank(),         axis.text.y = element_blank()) + scale_color_manual(values = c(\"#e87d72\",\"#54bcc2\")) #> Warning: The `size` argument of `element_rect()` is deprecated as of ggplot2 3.4.0. #> ℹ Please use the `linewidth` argument instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was #> generated. #Identify domain marker genes in the real dataset based on the BayesSpace clustering result, follow Seurat tutorial #create Seurat object real_count_dataset <- real_sce@assays@data$counts real_seurat <- CreateSeuratObject(counts = real_count_dataset, project = \"real_seurat\", min.cells = 0, min.features = 0) real_seurat[[\"percent.mt\"]] <- PercentageFeatureSet(real_seurat, pattern = \"^MT-\") real_seurat <- NormalizeData(real_seurat, normalization.method = \"LogNormalize\", scale.factor = 10000) #> Normalizing layer: counts real_seurat <- ScaleData(real_seurat, features = rownames(real_seurat)) #> Centering and scaling data matrix real_ct <-real_sce_clu$spatial.cluster names(real_ct) <- colnames(real_sce) real_seurat[[\"cell_type\"]] <- real_ct Idents(real_seurat) <- \"cell_type\" #Then we follow seurat tutorial to conduct DE analysis real_markers <- FindMarkers(object = real_seurat, ident.1 = unique(real_ct)[1], ident.2 =  unique(real_ct)[2], test.use = \"wilcox\",logfc.threshold = 0, min.pct = 0, min.cells.feature = 1, min.cells.group = 1) #> For a (much!) faster implementation of the Wilcoxon Rank Sum Test, #> (default method for FindMarkers) please install the presto package #> -------------------------------------------- #> install.packages('devtools') #> devtools::install_github('immunogenomics/presto') #> -------------------------------------------- #> After installation of presto, Seurat will automatically use the more  #> efficient implementation (no further action necessary). #> This message will be shown once per session real_pvals <- real_markers[rownames(real_seurat),\"p_val\"] names(real_pvals) <- rownames(real_seurat)"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-twodomains.html","id":"perform-clusterde-analysis","dir":"Articles","previous_headings":"","what":"Perform ClusterDE analysis","title":"Perform ClusterDE on a two-domain spatial dataset","text":"first generate synthetic null data based real data (target data). can increase number cores speed using parameter “nCores”. perform pipeline target data. Please note need two spatial clusters , . Visualize spatial clustering results based synthetic null data. Perform common DE test (Wilcoxon Rank Sum Test) synthetic null data. extract p-values target data synthetic null data, use ClusterDE “compare” . visualize top DE genes ClusterDE. expected, top genes detected ClusterDE exhibit clear spatial expression patterns.","code":"###generate synthetic null data count_mat <- real_sce@assays@data$counts location_mat <- data.frame(X=real_sce$spatial1,Y=real_sce$spatial2) system.time(null_twodomain_dataset <- ClusterDE::constructNull(mat=count_mat,                                                    family = \"nb\",                                                    extraInfo=location_mat,                                                    formula = \"s(X, Y, bs = 'gp', k= 4)\",                                                    nCores = 2)) #> 100% of genes are used in correlation modelling. #>    user  system elapsed  #>  50.630  34.791  24.817 ###construct the input of BayesSpace based on null dataset###### null_sce <- SingleCellExperiment(list(counts =null_twodomain_dataset)) # add colData information of singlecellexperiment null_sce$row <- real_sce$spatial1 null_sce$col <- real_sce$spatial2 ## log-normalize the count data set.seed(102) null_sce<- spatialPreprocess(null_sce, platform=\"ST\", n.PCs=7,log.normalize=TRUE) #clustering with BayesSpace set.seed(149) null_sce <- spatialCluster(null_sce, q=2, platform=\"ST\", d=7,                            init.method=\"mclust\", model=\"t\", gamma=2,                            nrep=1000, burn.in=100,                            save.chain=TRUE) #> Neighbors were identified for 0 out of 1205 spots. #> Fitting model... #> You created a large dataset with compression and chunking. #> The chunk size is equal to the dataset dimensions. #> If you want to read subsets of the dataset, you should testsmaller chunk sizes to improve read times. #> You created a large dataset with compression and chunking. #> The chunk size is equal to the dataset dimensions. #> If you want to read subsets of the dataset, you should testsmaller chunk sizes to improve read times. #> Calculating labels using iterations 100 through 1000. #visualize the spatial cluster null_spatial_clu <-  data.frame(Xaxis=null_sce$row,Yaxis=null_sce$col,Clusters=as.character(null_sce$spatial.cluster)) ggplot(null_spatial_clu, aes(x = Xaxis, y = Yaxis, col =Clusters))  + geom_point(size=1.0) + coord_equal() +   ggtitle(\"Synthetic null data \\n (spatial clusters detected by BayesSpace)\") +    #scale_color_brewer(palette = \"Accent\") +   theme(plot.title = element_text(size=10,hjust=0.5),         panel.grid=element_blank(),         panel.background = element_rect(fill = \"gray90\"),         panel.border = element_rect(color = \"black\", fill = NA, size = 0.6),         axis.title.x = element_blank(),         axis.title.y = element_blank(),         axis.ticks.x = element_blank(),         axis.ticks.y = element_blank(),         axis.text.x = element_blank(),         axis.text.y = element_blank()) + scale_color_manual(values = c(\"#e87d72\",\"#54bcc2\")) #Identify domain marker genes in the synthetic null dataset based on the BayesSpace clustering result, follow Seurat tutorial #create Seurat object null_count_dataset <- null_twodomain_dataset null_seurat <- CreateSeuratObject(counts = null_count_dataset, project = \"null_seurat\", min.cells = 0, min.features = 0) null_seurat[[\"percent.mt\"]] <- PercentageFeatureSet(null_seurat, pattern = \"^MT-\") null_seurat <- NormalizeData(null_seurat, normalization.method = \"LogNormalize\", scale.factor = 10000) #> Normalizing layer: counts null_seurat <- ScaleData(null_seurat, features = rownames(null_seurat)) #> Centering and scaling data matrix null_ct <- null_sce$spatial.cluster names(null_ct) <- colnames(null_sce) null_seurat[[\"cell_type\"]] <- null_ct Idents(null_seurat) <- \"cell_type\" #Then we follow seurat tutorial to conduct DE analysis null_markers <- FindMarkers(object = null_seurat, ident.1 = unique(null_ct)[1], ident.2 =  unique(null_ct)[2], test.use = \"wilcox\",logfc.threshold = 0, min.pct = 0, min.cells.feature = 1, min.cells.group = 1) null_pvals <- null_markers[rownames(null_seurat),\"p_val\"] names(null_pvals) <- rownames(null_seurat) ###you can set the value of FDR, the default value is 0.05 res <- ClusterDE::callDE(real_pvals, null_pvals, nlogTrans = TRUE) cat(paste0(\"The number of domain marker genes is: \",length(res$DEgenes),sep=\"\")) #> The number of domain marker genes is: 130"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-twodomains.html","id":"visualize-top-marker-genes","dir":"Articles","previous_headings":"","what":"Visualize top marker genes","title":"Perform ClusterDE on a two-domain spatial dataset","text":"","code":"expression_dat_test <- data.frame(scales::rescale(as.matrix(t(log1p(counts(real_sce)))))) %>% as_tibble() %>% dplyr::mutate(X = colData(real_sce)$spatial1, Y = colData(real_sce)$spatial2) %>% tidyr::pivot_longer(-c(\"X\", \"Y\"), names_to = \"Gene\", values_to = \"Expression\")  top_DE_ClusterDE <- res$DEgenes  p_topGenes <- expression_dat_test %>% as_tibble() %>% dplyr::mutate(Method = \"ClusterDE\") %>% filter(Gene %in% top_DE_ClusterDE[1:5]) %>% dplyr::mutate(Gene = factor(Gene, levels = top_DE_ClusterDE[1:5])) %>% ggplot(aes(x = X, y = Y, color = Expression)) + geom_point(size = 0.1) + scale_colour_gradientn(colors = viridis_pal(option = \"magma\")(10)) + coord_fixed(ratio = 1) + facet_grid(Method ~ Gene)+ theme_gray() + theme(axis.text.x = element_blank(), axis.text.y = element_blank(), axis.ticks.x = element_blank(), axis.ticks.y = element_blank(), legend.position = \"bottom\")  p_topGenes"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-twodomains.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Perform ClusterDE on a two-domain spatial dataset","text":"","code":"sessionInfo() #> R version 4.4.1 (2024-06-14) #> Platform: x86_64-pc-linux-gnu #> Running under: Ubuntu 22.04.4 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] scales_1.3.0                dplyr_1.1.4                 #>  [3] BayesSpace_1.14.0           ClusterDE_0.99.3            #>  [5] ggplot2_3.5.1               spatialLIBD_1.16.2          #>  [7] SpatialExperiment_1.14.0    SingleCellExperiment_1.26.0 #>  [9] SummarizedExperiment_1.34.0 Biobase_2.64.0              #> [11] GenomicRanges_1.56.1        GenomeInfoDb_1.40.1         #> [13] IRanges_2.38.1              S4Vectors_0.42.1            #> [15] BiocGenerics_0.50.0         MatrixGenerics_1.16.0       #> [17] matrixStats_1.3.0           Seurat_5.1.0                #> [19] SeuratObject_5.0.2          sp_2.1-4                    #> [21] BiocStyle_2.32.1            #>  #> loaded via a namespace (and not attached): #>   [1] DirichletReg_0.7-1        goftest_1.2-3             #>   [3] DT_0.33                   Biostrings_2.72.1         #>   [5] vctrs_0.6.5               spatstat.random_3.3-1     #>   [7] digest_0.6.36             png_0.1-8                 #>   [9] ggrepel_0.9.5             deldir_2.0-4              #>  [11] parallelly_1.38.0         magick_2.8.4              #>  [13] MASS_7.3-60.2             pkgdown_2.1.0             #>  [15] reshape2_1.4.4            httpuv_1.6.15             #>  [17] foreach_1.5.2             withr_3.0.1               #>  [19] xfun_0.46                 survival_3.6-4            #>  [21] memoise_2.0.1             benchmarkme_1.0.8         #>  [23] ggbeeswarm_0.7.2          systemfonts_1.1.0         #>  [25] ragg_1.3.2                zoo_1.8-12                #>  [27] pbapply_1.7-2             Formula_1.2-5             #>  [29] rematch2_2.1.2            KEGGREST_1.44.1           #>  [31] promises_1.3.0            httr_1.4.7                #>  [33] restfulr_0.0.15           randtoolbox_2.0.4         #>  [35] globals_0.16.3            fitdistrplus_1.2-1        #>  [37] rhdf5filters_1.16.0       rhdf5_2.48.0              #>  [39] UCSC.utils_1.0.0          miniUI_0.1.1.1            #>  [41] generics_0.1.3            curl_5.2.1                #>  [43] fields_16.2               zlibbioc_1.50.0           #>  [45] ScaledMatrix_1.12.0       polyclip_1.10-7           #>  [47] GenomeInfoDbData_1.2.12   ExperimentHub_2.12.0      #>  [49] SparseArray_1.4.8         golem_0.4.1               #>  [51] xtable_1.8-4              stringr_1.5.1             #>  [53] desc_1.4.3                doParallel_1.0.17         #>  [55] evaluate_0.24.0           S4Arrays_1.4.1            #>  [57] BiocFileCache_2.12.0      bookdown_0.40             #>  [59] irlba_2.3.5.1             colorspace_2.1-1          #>  [61] filelock_1.0.3            ROCR_1.0-11               #>  [63] reticulate_1.38.0         spatstat.data_3.1-2       #>  [65] shinyWidgets_0.8.6        magrittr_2.0.3            #>  [67] lmtest_0.9-40             later_1.3.2               #>  [69] viridis_0.6.5             lattice_0.22-6            #>  [71] spatstat.geom_3.3-2       future.apply_1.11.2       #>  [73] scattermore_1.2           XML_3.99-0.17             #>  [75] scuttle_1.14.0            cowplot_1.1.3             #>  [77] RcppAnnoy_0.0.22          pillar_1.9.0              #>  [79] nlme_3.1-164              iterators_1.0.14          #>  [81] compiler_4.4.1            beachmat_2.20.0           #>  [83] RSpectra_0.16-2           stringi_1.8.4             #>  [85] tensor_1.5                GenomicAlignments_1.40.0  #>  [87] plyr_1.8.9                crayon_1.5.3              #>  [89] abind_1.4-5               BiocIO_1.14.0             #>  [91] scater_1.32.1             locfit_1.5-9.10           #>  [93] bit_4.0.5                 sandwich_3.1-0            #>  [95] codetools_0.2-20          textshaping_0.4.0         #>  [97] BiocSingular_1.20.0       rngWELL_0.10-9            #>  [99] coop_0.6-3                bslib_0.8.0               #> [101] paletteer_1.6.0           plotly_4.10.4             #> [103] mime_0.12                 splines_4.4.1             #> [105] Rcpp_1.0.13               fastDummies_1.7.3         #> [107] dbplyr_2.5.0              sparseMatrixStats_1.16.0  #> [109] attempt_0.3.1             maxLik_1.5-2.1            #> [111] knitr_1.48                blob_1.2.4                #> [113] utf8_1.2.4                BiocVersion_3.19.1        #> [115] fs_1.6.4                  listenv_0.9.1             #> [117] DelayedMatrixStats_1.26.0 tibble_3.2.1              #> [119] Matrix_1.7-0              statmod_1.5.0             #> [121] pkgconfig_2.0.3           tools_4.4.1               #> [123] cachem_1.1.0              RSQLite_2.3.7             #> [125] viridisLite_0.4.2         DBI_1.2.3                 #> [127] fastmap_1.2.0             rmarkdown_2.27            #> [129] grid_4.4.1                ica_1.0-3                 #> [131] Rsamtools_2.20.0          AnnotationHub_3.12.0      #> [133] sass_0.4.9                patchwork_1.2.0           #> [135] coda_0.19-4.1             BiocManager_1.30.23       #> [137] dotCall64_1.1-1           RANN_2.6.1                #> [139] farver_2.1.2              yaml_2.3.10               #> [141] kde1d_1.0.7               rtracklayer_1.64.0        #> [143] cli_3.6.3                 purrr_1.0.2               #> [145] leiden_0.4.3.1            lifecycle_1.0.4           #> [147] uwot_0.2.2                bluster_1.14.0            #> [149] sessioninfo_1.2.2         BiocParallel_1.38.0       #> [151] gtable_0.3.5              rjson_0.2.21              #> [153] ggridges_0.5.6            progressr_0.14.0          #> [155] parallel_4.4.1            limma_3.60.4              #> [157] jsonlite_1.8.8            edgeR_4.2.1               #> [159] miscTools_0.6-28          RcppHNSW_0.6.0            #> [161] rvinecopulib_0.6.3.1.1    bitops_1.0-8              #> [163] benchmarkmeData_1.0.4     bit64_4.0.5               #> [165] assertthat_0.2.1          xgboost_1.7.8.1           #> [167] Rtsne_0.17                spatstat.utils_3.0-5      #> [169] BiocNeighbors_1.22.0      jquerylib_0.1.4           #> [171] highr_0.11                metapod_1.12.0            #> [173] config_0.3.2              dqrng_0.4.1               #> [175] spatstat.univar_3.0-0     lazyeval_0.2.2            #> [177] shiny_1.9.1               htmltools_0.5.8.1         #> [179] sctransform_0.4.1         rappdirs_0.3.3            #> [181] glue_1.7.0                spam_2.10-0               #> [183] XVector_0.44.0            RCurl_1.98-1.16           #> [185] scran_1.32.0              mclust_6.1.1              #> [187] mvnfast_0.2.8             gridExtra_2.3             #> [189] igraph_2.0.3              R6_2.5.1                  #> [191] tidyr_1.3.1               labeling_0.4.3            #> [193] cluster_2.1.6             Rhdf5lib_1.26.0           #> [195] DelayedArray_0.30.1       tidyselect_1.2.1          #> [197] vipor_0.4.7               maps_3.4.2                #> [199] AnnotationDbi_1.66.0      future_1.34.0             #> [201] rsvd_1.0.5                munsell_0.5.1             #> [203] KernSmooth_2.23-24        data.table_1.15.4         #> [205] htmlwidgets_1.6.4         RColorBrewer_1.1-3        #> [207] rlang_1.1.4               spatstat.sparse_3.1-0     #> [209] spatstat.explore_3.3-1    fansi_1.0.6               #> [211] beeswarm_0.4.0"},{"path":"https://songdongyuan1994.github.io/ClusterDE/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Dongyuan Song. Author, maintainer. Kexin Li. Author. Siqi Chen. Author.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Song D, Li K, Chen S (2024). ClusterDE: Post-clustering Differential Expression (DE) Method Solving Double Dipping. R package version 0.99.3, https://songdongyuan1994.github.io/ClusterDE/, https://github.com/SONGDONGYUAN1994/ClusterDE.","code":"@Manual{,   title = {ClusterDE: A Post-clustering Differential Expression (DE) Method For Solving Double Dipping},   author = {Dongyuan Song and Kexin Li and Siqi Chen},   year = {2024},   note = {R package version 0.99.3, https://songdongyuan1994.github.io/ClusterDE/},   url = {https://github.com/SONGDONGYUAN1994/ClusterDE}, }"},{"path":"https://songdongyuan1994.github.io/ClusterDE/index.html","id":"clusterde","dir":"","previous_headings":"","what":"ClusterDE","title":"A Post-clustering Differential Expression (DE) Method For Solving Double Dipping","text":"R package ClusterDE post-clustering DE method controlling false discovery rate (FDR) identified cell-type DE genes regardless clustering quality. core idea ClusterDE generate real-data-based synthetic null data one cell type, contrast real data, evaluating whole procedure clustering followed DE test.  Detailed tutorials illustrate various functionalities ClusterDE available website. following illustration figure summarizes usage ClusterDE:  Instead new pipeline, ClusterDE actually works add-popular pipelines Seurat. find details ClusterDE, can check manuscript bioRxiv.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/index.html","id":"changelog","dir":"","previous_headings":"","what":"Changelog","title":"A Post-clustering Differential Expression (DE) Method For Solving Double Dipping","text":"Add functions spatial clustering motivation application ClusterDE: Seurat function findMarkers, authors pointed : “p-values interpreted cautiously, genes used clustering genes tested differential expression.” “double-dipping” issue. clustering results inaccurate since clustering used expression data already, discovered DE genes may represent discrete cell type separation, variation data (e.g., cell cycle, total UMI, variation clear. still biological variation define discrete status). ClusterDE aims correcting double-dipping issue comparing two dubious clusters, sure two discrete cell types just artifact clustering algorithm based conventional DE analysis. ClusterDE controls false discoveries DE prioritizes true cell type markers. Note: current version focusing one vs one comparison.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A Post-clustering Differential Expression (DE) Method For Solving Double Dipping","text":"install development version GitHub, please run: Please note ClusterDE actually wrapper scDesign3. Therefore, can also directly use scDesign3 “design” synthetic null data. better understand scDesign3, can check manuscript Nature Biotechnology: Song, D., Wang, Q., Yan, G. et al. scDesign3 generates realistic silico data multimodal single-cell spatial omics. Nat Biotechnol (2023).","code":"if (!require(\"devtools\", quietly = TRUE))     install.packages(\"devtools\") devtools::install_github(\"SONGDONGYUAN1994/scDesign3\") devtools::install_github(\"SONGDONGYUAN1994/ClusterDE\")"},{"path":"https://songdongyuan1994.github.io/ClusterDE/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"A Post-clustering Differential Expression (DE) Method For Solving Double Dipping","text":"following code quick example generate synthetic null data. input data gene cell matrix containing two clusters want compare. input matrix count data (especially UMI counts), nb (Negative Binomial) usually appropriate choice. synthetic null data generation relatively time-consuming; may use fast version (fastVersion = TRUE). parameters constructNull() : mat: input gene cell matrix. can sparse matrix. family: string distribution want use fitting model. Must one ‘poisson’, ‘nb’, ‘zip’, ‘zinb’ ‘gaussian’. formula: string mu parameter formula. defines relationship gene expression synthetic null data extra covariates. Default NULL (cell type case). example, input data spatial data X, Y coordinates, formula can ‘s(X, Y, bs = ’gp’, k = 4)’. extraInfo: data frame extra covariates used . example, 2D spatial coordinates. Default NULL. nCores: integer. number cores use. Increasing cores greatly speed computation. parallelization: string indicating specific parallelization function use. Must one ‘mcmapply’, ‘bpmapply’, ‘pbmcmapply’, corresponds parallelization function package ‘parallel’, ‘BiocParallel’, ‘pbmcapply’ respectively. default value ‘pbmcmapply’. fastVersion: logic value. TRUE, fast approximation used. corrCut: numeric value. cutoff non-zero proportions genes used modelling correlation. reason lowly expressed genes hard calculate correlation. BPPARAM: MulticoreParam object NULL. parameter parallelization = ‘mcmapply’ ‘pbmcmapply’, parameter must NULL. parameter parallelization = ‘bpmapply’, parameter must one MulticoreParam object offered package ‘BiocParallel’. default value NULL. output constructNull() new gene cell matrix format input. following figure briefly describes ClusterDE generates synthetic null data:  obtaining synthetic null data, perform clustering procedure done real data get DE p-values (nullPvalues). Finally, compare p-values null p-values target data (real data) callDE(). illustration, use Uniform random numbers p-values. parameters callDE : targetScores: named numeric vector DE scores target data, e.g., p-values two clusters real data. nullScores: named numeric vector DE scores synthetic null data, e.g., p-values two clusters null data. nlogTrans: logical value. input scores p-values, take -log10 transformation since Clipper require larger scores represent significant DE. Default TRUE. FDR: numeric value target False Discovery Rate (FDR). Default 0.05. correct: logical value. TRUE, perform correction make distribution contrast scores approximately symmetric. Default FALSE. output callDE list target FDR, DE genes, detailed summary table.","code":"data(exampleCounts) nullData <- constructNull(mat = exampleCounts,                           family = \"nb\",                           formula = NULL,                           extraInfo = NULL,                           nCores = 1,                           parallelization = \"mcmapply\",                           fastVersion = FALSE,                           corrCut = 0.2,                           BPPARAM = NULL) set.seed(123) targetPvalues <- runif(10000) nullPvalues <- runif(10000) names(targetPvalues) <- names(nullPvalues) <- paste0(\"Gene\", 1:10000) res <- callDE(targetScores = targetPvalues,               nullScores = nullPvalues,               nlogTrans = TRUE,               FDR = 0.05,               correct = FALSE)"},{"path":"https://songdongyuan1994.github.io/ClusterDE/index.html","id":"tutorials","dir":"","previous_headings":"","what":"Tutorials","title":"A Post-clustering Differential Expression (DE) Method For Solving Double Dipping","text":"detailed tutorials, please check website. tutorials demonstrate applications ClusterDE two cases: cell line dataset (cell type exists) PBMC dataset. Perform ClusterDE cell line dataset Perform ClusterDE PBMC dataset Perform ClusterDE single-domain spatial transcriptomics dataset Perform ClusterDE two-domains spatial transcriptomics dataset","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact","title":"A Post-clustering Differential Expression (DE) Method For Solving Double Dipping","text":"questions suggestions ClusterDE welcomed! Please report issues, contact Dongyuan Song (dongyuansong@ucla.edu).","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/index.html","id":"related-papers","dir":"","previous_headings":"","what":"Related Papers","title":"A Post-clustering Differential Expression (DE) Method For Solving Double Dipping","text":"scDesign3: Song, D., Wang, Q., Yan, G. et al. scDesign3 generates realistic silico data multimodal single-cell spatial omics. Nat Biotechnol (2023). Clipper: Ge, X., Chen, Y.E., Song, D. et al. Clipper: p-value-free FDR control high-throughput data two conditions. Genome Biology 22, 288 (2021).","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/index.html","id":"other-methods-for-double-dipping-problem","dir":"","previous_headings":"","what":"Other methods for double dipping problem","title":"A Post-clustering Differential Expression (DE) Method For Solving Double Dipping","text":"TN test: Zhang, J.M., Kamath, G.M., David, N.T. Valid post-clustering differential analysis single-cell rna-seq. Cell Systems, 2019 count split: Neufeld, ., Gao, L.L., Popp, J., Battle, ., Witten, D. Inference latent variable estimation single-cell RNA sequencing data. Biostatistics, 2022","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/callDE.html","id":null,"dir":"Reference","previous_headings":"","what":"Call differentially expressed (DE) genes by Clipper algorithm — callDE","title":"Call differentially expressed (DE) genes by Clipper algorithm — callDE","text":"callDE takes two vectors representing gene's significance. usually p-values target data synthetic null data.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/callDE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Call differentially expressed (DE) genes by Clipper algorithm — callDE","text":"","code":"callDE(   targetScores,   nullScores,   nlogTrans = TRUE,   FDR = 0.05,   correct = FALSE,   threshold = \"BC\",   ordering = TRUE )"},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/callDE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Call differentially expressed (DE) genes by Clipper algorithm — callDE","text":"targetScores named numeric vector DE scores target data, e.g., p-values two clusters real data. nullScores named numeric vector DE scores synthetic null data, e.g., p-values two clusters null data. nlogTrans logical value. input scores p-values, take -log10 transformation since Clipper require larger scores represent significant DE. Default TRUE. FDR numeric value target False Discovery Rate (FDR). Default 0.05. correct logical value. TRUE, perform correction make distribution contrast scores approximately symmetric. Default FALSE. threshold string value threshold method. Must 'BC' 'DS'. ordering logic value. TRUE, order genes returned table significance. Default TRUE.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/callDE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Call differentially expressed (DE) genes by Clipper algorithm — callDE","text":"list target FDR, DE genes, detailed summary table.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/callDE.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Call differentially expressed (DE) genes by Clipper algorithm — callDE","text":"function constructs contrast scores taking difference target DE scores null DE scores.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/callDE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Call differentially expressed (DE) genes by Clipper algorithm — callDE","text":"","code":"targetScores <- runif(10000) nullScores <- runif(10000) names(targetScores) <- names(nullScores) <- paste0(\"Gene\", 1:10000) res <- callDE(targetScores, nullScores, correct = FALSE)"},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/constructNull.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct the synthetic null data — constructNull","title":"Construct the synthetic null data — constructNull","text":"constructNull takes target data input returns corresponding synthetic null data.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/constructNull.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct the synthetic null data — constructNull","text":"","code":"constructNull(   mat,   family = \"nb\",   formula = NULL,   extraInfo = NULL,   nCores = 1,   parallelization = \"mcmapply\",   fastVersion = TRUE,   ifSparse = FALSE,   corrCut = 0.1,   BPPARAM = NULL )"},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/constructNull.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct the synthetic null data — constructNull","text":"mat expression matrix (gene cell). can regular dense matrix sparseMatrix. family string vector strings distribution data. Must one 'nb', 'binomial', 'poisson', 'zip', 'zinb' 'gaussian', represent 'poisson distribution', 'negative binomial distribution', 'zero-inflated poisson distribution', 'zero-inflated negative binomail distribution', 'gaussian distribution' respectively. UMI-counts data, usually use 'nb'. Default 'nb'. formula string mu parameter formula. defines relationship gene expression synthetic null data extra covariates. Default NULL (cell type case). example, input data spatial data X, Y coordinates, formula can 's(X, Y, bs = 'gp', k = 4)'. extraInfo data frame extra covariates used formula. example, 2D spatial coordinates. Default NULL. nCores integer. number cores use Parallel processing. parallelization string indicating specific parallelization function use. Must one 'mcmapply', 'bpmapply', 'pbmcmapply', corresponds parallelization function package parallel,BiocParallel, pbmcapply respectively. default value 'pbmcmapply'. fastVersion logic value. TRUE, fast approximation used. Default FALSE. ifSparse logic value. high-dimentional data (gene number much larger cell number), sparse correlation estimation used. Default FALSE. corrCut numeric value. cutoff non-zero proportions genes used modelling correlation. BPPARAM MulticoreParam object NULL. parameter parallelization = 'mcmapply' 'pbmcmapply', parameter must NULL. parameter parallelization = 'bpmapply',  parameter must one MulticoreParam object offered package 'BiocParallel. default value NULL.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/constructNull.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct the synthetic null data — constructNull","text":"expression matrix synthetic null data.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/constructNull.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct the synthetic null data — constructNull","text":"function constructs synthetic null data based target data (real data). input expression matrix (gene cell); user specify distribution, usually Negative Binomial count matrix.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/constructNull.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct the synthetic null data — constructNull","text":"","code":"data(exampleCounts) nullData <- constructNull(mat = exampleCounts) #> 95% of genes are used in correlation modelling."},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/exampleCounts.html","id":null,"dir":"Reference","previous_headings":"","what":"A count matrix of 100 genes from the A549 cell line from Tian et al., Nature Methods, 2019. — exampleCounts","title":"A count matrix of 100 genes from the A549 cell line from Tian et al., Nature Methods, 2019. — exampleCounts","text":"count matrix 100 genes A549 cell line Tian et al., Nature Methods, 2019.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/exampleCounts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A count matrix of 100 genes from the A549 cell line from Tian et al., Nature Methods, 2019. — exampleCounts","text":"","code":"data(\"exampleCounts\")"},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/exampleCounts.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A count matrix of 100 genes from the A549 cell line from Tian et al., Nature Methods, 2019. — exampleCounts","text":"dataset 100 rows (genes) 1256 cols (cells)","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/exampleCounts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A count matrix of 100 genes from the A549 cell line from Tian et al., Nature Methods, 2019. — exampleCounts","text":"corresponding count matrix object","code":""}]
