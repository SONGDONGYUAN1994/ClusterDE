[{"path":"https://songdongyuan1994.github.io/ClusterDE/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2023 ClusterDE authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-PBMC.html","id":"download-data","dir":"Articles","previous_headings":"","what":"Download data","title":"Perform ClusterDE on a PBMC dataset","text":"PBMC datasets originally SeuratData. use one (10x Chromium (v3) PBMC1 replicate). filtered lowly epxressed genes save computational time .","code":"# InstallData(\"pbmcsca\") # data(\"pbmcsca\") # pbmc <- pbmcsca[, pbmcsca@meta.data$Method==\"10x Chromium (v3)\" & pbmcsca@meta.data$Experiment == \"pbmc1\"] #  # pbmc <- pbmc[Matrix::rowSums(pbmc@assays$RNA@counts) > 100, ]  pbmc <- readRDS(url(\"https://figshare.com/ndownloader/files/41486283\"))"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-PBMC.html","id":"run-the-regular-seurat-pipeline","dir":"Articles","previous_headings":"","what":"Run the regular Seurat pipeline","title":"Perform ClusterDE on a PBMC dataset","text":"perform default Seurat clustering. Note real data analysis, cell type label usually unknown.  vignette, interested cluster 2 vs 8, approximately represent CD14+/CD16+ monocytes. Please note ClusterDE designed 1 vs 1 comparison. Therefore, users may (1) choose two interested clusters manually based knowledge (2) use two closest clusters computation (e.g., BuildClusterTree Seurat).  perform DE test cluster 2 8. subset cluster 2 8 (pbmc_sub).","code":"RNGkind(\"L'Ecuyer-CMRG\") set.seed(123) pbmc <- NormalizeData(object = pbmc) pbmc <- FindVariableFeatures(object = pbmc) pbmc <- ScaleData(object = pbmc) #> Centering and scaling data matrix pbmc <- RunPCA(object = pbmc) #> PC_ 1  #> Positive:  IL32, CCL5, TRBC2, TRAC, CD69, CST7, RORA, CTSW, SPOCK2, ITM2A  #>     GZMM, CD247, TRBC1, C12orf75, IL7R, CD8A, CD2, LDHB, GZMA, CD7  #>     NKG7, CD6, GZMH, CD8B, BCL11B, PRF1, LYAR, LTB, FGFBP2, TCF7  #> Negative:  LYZ, FCN1, CLEC7A, CPVL, SERPINA1, SPI1, S100A9, AIF1, NAMPT, CSTA  #>     CTSS, MAFB, MPEG1, NCF2, VCAN, FGL2, S100A8, TYMP, CST3, LST1  #>     CYBB, CFD, FCER1G, SLC11A1, TGFBI, GRN, CD14, PSAP, SLC7A7, MS4A6A  #> PC_ 2  #> Positive:  RPL10, EEF1A1, TMSB10, RPS2, RPS12, RPL13, RPS18, RPS23, RPLP1, TPT1  #>     RPS8, IL32, S100A4, PFN1, RPLP0, NKG7, ARL4C, HSPA8, CST7, ZFP36L2  #>     ANXA1, CTSW, S100A6, LDHA, CORO1A, CD247, GZMA, CALR, S100A10, GZMM  #> Negative:  NRGN, PF4, SDPR, HIST1H2AC, MAP3K7CL, PPBP, GNG11, GPX1, TUBB1, SPARC  #>     CLU, PGRMC1, FTH1, RGS18, MARCH2, TREML1, HIST1H3H, AP003068.23, NCOA4, ACRBP  #>     TAGLN2, PRKAR2B, CD9, CA2, CMTM5, CTTN, MTURN, TMSB4X, HIST1H2BJ, TSC22D1  #> PC_ 3  #> Positive:  CD79A, HLA-DQA1, MS4A1, LINC00926, IGHM, BANK1, IGHD, TNFRSF13C, HLA-DQB1, CD74  #>     IGKC, HLA-DRA, BLK, CD83, CD37, CD22, ADAM28, JUND, NFKBID, HLA-DRB1  #>     P2RX5, CD79B, VPREB3, IGLC2, FCER2, RPS8, LTB, RPS23, TCOF1, GNG7  #> Negative:  CCL5, TMSB4X, SRGN, NKG7, ACTB, CST7, GZMH, FGFBP2, CTSW, PRF1  #>     GZMA, GZMB, C12orf75, S100A4, ANXA1, KLRD1, NRGN, GNLY, GZMM, IL32  #>     PF4, SDPR, PPBP, MYO1F, CD247, GAPDH, MAP3K7CL, HIST1H2AC, GNG11, TUBB1  #> PC_ 4  #> Positive:  FCGR3A, GZMB, FGFBP2, GZMH, NKG7, HLA-DPA1, PRF1, HLA-DPB1, CST7, GNLY  #>     KLRD1, HLA-DRB1, GZMA, CCL5, SPON2, ADGRG1, CTSW, ZEB2, PRSS23, IFITM2  #>     CCL4, CD74, KLRF1, RHOC, MTSS1, CDKN1C, CD79B, CEP78, HLA-DQA1, CLIC3  #> Negative:  IL7R, LEPROTL1, LTB, RCAN3, MAL, LEF1, TCF7, ZFP36L2, CAMK4, VIM  #>     LDHB, NOSIP, JUNB, SLC2A3, TRABD2A, RGCC, SATB1, TNFAIP3, TMEM123, SOCS3  #>     AQP3, BCL11B, NELL2, TNFRSF25, CD28, PABPC1, DNAJB1, TRAT1, OXNAD1, TRAC  #> PC_ 5  #> Positive:  CDKN1C, HES4, CSF1R, CKB, ZNF703, TCF7L2, CTSL, MS4A7, PAG1, FAM110A  #>     SIGLEC10, LRRC25, FCGR3A, LTB, RNASET2, CDH23, IL7R, RRAS, LINC01272, IFITM3  #>     LST1, LILRB2, PILRA, RHOC, SLC2A6, PECAM1, CAMK1, TAGLN, IFI30, BID  #> Negative:  VCAN, S100A12, S100A8, CD14, CSF3R, ITGAM, CST7, GZMB, MT-CO1, GNLY  #>     KLRD1, PRF1, MS4A6A, GZMH, FGFBP2, CD93, EGR1, NKG7, S100A9, MT-CO3  #>     IER3, THBS1, RNASE6, CLEC4E, MGST1, CTSW, SGK1, GZMA, RP11-1143G9.4, CH17-373J23.1 pbmc <- FindNeighbors(object = pbmc) #> Computing nearest neighbor graph #> Computing SNN pbmc <- FindClusters(object = pbmc, resolution = 0.3) #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 3222 #> Number of edges: 108605 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.9363 #> Number of communities: 10 #> Elapsed time: 0 seconds pbmc <- RunUMAP(object = pbmc, dims = 1:10) #> Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric #> To use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation' #> This message will be shown once per session #> 01:05:20 UMAP embedding parameters a = 0.9922 b = 1.112 #> 01:05:20 Read 3222 rows and found 10 numeric columns #> 01:05:20 Using Annoy for neighbor search, n_neighbors = 30 #> 01:05:20 Building Annoy index with metric = cosine, n_trees = 50 #> 0%   10   20   30   40   50   60   70   80   90   100% #> [----|----|----|----|----|----|----|----|----|----| #> **************************************************| #> 01:05:21 Writing NN index file to temp file /tmp/RtmpOiuxLd/file1bbb5de547e5 #> 01:05:21 Searching Annoy index using 1 thread, search_k = 3000 #> 01:05:22 Annoy recall = 100% #> 01:05:22 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30 #> 01:05:23 Initializing from normalized Laplacian + noise (using irlba) #> 01:05:23 Commencing optimization for 500 epochs, with 126446 positive edges #> 01:05:28 Optimization finished p1 <- DimPlot(object = pbmc, reduction = \"umap\", label = TRUE) + ggtitle(\"Clustering result\") + NoLegend() p2 <- DimPlot(object = pbmc, reduction = \"umap\", group.by = \"CellType\", label = TRUE) + NoLegend() p1 + p2 pbmc <- BuildClusterTree(pbmc) PlotClusterTree(pbmc) pbmc_sub <- subset(x = pbmc, idents = c(2, 8)) original_markers <- FindMarkers(pbmc_sub,                                  ident.1 = 2,                                  ident.2 = 8,                                  min.pct = 0,                                  logfc.threshold = 0) #> For a more efficient implementation of the Wilcoxon Rank Sum Test, #> (default method for FindMarkers) please install the limma package #> -------------------------------------------- #> install.packages('BiocManager') #> BiocManager::install('limma') #> -------------------------------------------- #> After installation of limma, Seurat will automatically use the more  #> efficient implementation (no further action necessary). #> This message will be shown once per session"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-PBMC.html","id":"generate-synthetic-null-data","dir":"Articles","previous_headings":"","what":"Generate synthetic null data","title":"Perform ClusterDE on a PBMC dataset","text":"first generate synthetic null data based target data (real subset data, pbmc_sub, contains two clusters interested ). can increase number cores speed . perform pipeline target data. Please note need two clusters , . straightforward clustering method predefined cluster numbers, e.g., K-means. louvain clustering used Seurat may manually adjust resolution parameter still get two clusters.  perform DE test synthetic null data. extract p-values original data synthetic null data, use ClusterDE “compare” . can check summary table. genes ranked “contrast score (cs)”. compare result naive Seurat pipeline ClusterDE, first visualize top 6 DE genes Seurat. Genes LST1 RPS19 highly expressed two clusters. addition, RPS19 reported stable housekeeping genes several studies. Note mean expression levels LST1 RPS19 two cell types. means good cell type markers. Philosophically speaking, means conditional two clusters obtained clustering algorithm, LST1 RPS19 less likely cell type markers two cell types. contrast, genes ClusterDE LST1 RPS19 anymore.","code":"count_mat <- GetAssayData(object = pbmc_sub, slot = \"counts\") set.seed(1234) system.time(synthetic_null <- ClusterDE::constructNull(count_mat, nCores = 2, fastVersion = TRUE)) #>    user  system elapsed  #> 103.225  34.213  72.018 pbmc_null <- CreateSeuratObject(counts = synthetic_null)  set.seed(123) pbmc_null <- NormalizeData(object = pbmc_null) pbmc_null <- FindVariableFeatures(object = pbmc_null) pbmc_null <- ScaleData(object = pbmc_null) #> Centering and scaling data matrix pbmc_null <- RunPCA(object = pbmc_null) #> PC_ 1  #> Positive:  RPS19, RPS27, RPL41, B2M, LST1, RPL10, AIF1, FTH1, COTL1, RPL8  #>     RPL19, RPL11, PFN1, NACA, EEF1A1, YBX1, HLA-C, FTL, FCER1G, HLA-B  #>     RPL7A, TMSB10, IFITM3, RPL14, RPL15, FAU, RPS2, CORO1A, TMSB4X, RNASET2  #> Negative:  VCAN, S100A8, SLC2A3, FOS, S100A9, S100A12, CD14, LYZ, CSF3R, ITGAM  #>     CD36, SELL, NCF1, RGS2, MS4A6A, DUSP6, GPX1, FPR1, FOSB, IRF2BP2  #>     NR4A2, ALOX5AP, THBS1, CCR1, RNASE6, ZFP36L1, RP11-1143G9.4, NRGN, CLEC4E, CXCL8  #> PC_ 2  #> Positive:  TPT1, RPS13, GAPDH, LYZ, GPX1, RPS18, RPS3A, VIM, RPL18A, RPL3  #>     RPL32, S100A10, RPS23, S100A9, RPS6, RPL6, RPS8, GRN, EEF1A1, CD14  #>     RPLP0, LGALS3, RPL34, FCN1, AP1S2, FOS, RPS12, LGALS2, RPL23A, RPL30  #> Negative:  CDKN1C, RHOC, IFITM2, FCGR3A, KLF2, POU2F2, PAG1, HES4, SLC2A6, LRRC25  #>     MS4A7, FAM110A, RRAS, PECAM1, CYTIP, LYST, DRAP1, IFITM3, CSF1R, HN1  #>     LYL1, MTSS1, SPN, SSBP4, UNC119, SNX9, SIGLEC10, SOD1, TMC6, BID  #> PC_ 3  #> Positive:  HLA-DRA, HLA-DPA1, HLA-DPB1, CPVL, MARCKS, MAP3K8, HLA-DRB1, CD74, EZR, XYLT1  #>     HMOX1, CST3, HLA-DQB1, CD300E, NAAA, DUSP6, BHLHE40, CD63, CDKN1A, APOBEC3A  #>     EMP3, ID2, RUNX3, DOK2, MAFB, CORO1C, RGCC, LGALS3, ADAP2, S100A11  #> Negative:  IRS2, RPS26, HMGB2, RNF144B, RGS2, RPL34, TNFSF10, RPL14, RPL30, S100A12  #>     EXOC1, CBX4, EGR1, RPS3, RPS12, ACSL1, RPL12, SOD2, CD48, ALOX5AP  #>     SELL, CLEC2B, S100A8, S100A9, RPS15A, GIMAP4, FAM53C, CNOT6L, BIN2, LEPROTL1  #> PC_ 4  #> Positive:  PLBD1, S100A8, S100A12, S100A9, CES1, SELL, FPR1, PLAC8, S100A11, RP11-1143G9.4  #>     VCAN, TUBA4A, SLA, FCN1, UBE2D4, LYZ, IRF7, IVNS1ABP, SOD2, MAFB  #>     OSM, ACTB, MBD2, BCL2A1, HELZ2, PPP3R1, GRN, SPTLC2, PIK3CG, PARP14  #> Negative:  HLA-DMB, ARL4C, HLA-DPB1, RPL30, HLA-DRA, RPL32, HLA-DPA1, RPL34, HLA-DQB1, RPS23  #>     AHR, SFT2D2, RPS3A, LNX2, AKNA, TXNIP, C5orf24, ANKDD1A, TUBB2A, ATM  #>     YBX3, RPS4X, RPL12, EEF1B2, RUNX3, RPL14, CD74, RPS12, TNFAIP3, POLR3C  #> PC_ 5  #> Positive:  IFI44, MX1, STOM, SHISA5, CCPG1, IFI44L, PLAC8, ISG15, APOL6, ZC3HAV1  #>     ATM, MGAT1, PARP14, PCBP2, CMPK2, MYLIP, LPP, AKNA, ARL4C, NKG7  #>     DDX6, AES, B2M, RAD21, IFIT3, LAP3, UBN1, PLSCR1, MZT2B, FAM53C  #> Negative:  S100A11, DUSP2, PLPPR2, ACTG1, ARPC3, DYRK2, CEP68, ZNF281, APH1B, PLAUR  #>     CXCL8, RASA1, CPEB2, LILRB2, EMX2, FTH1, FTL, RGS1, TFAP4, MARCKSL1  #>     VIM, ACADVL, CTB-61M7.2, IVNS1ABP, HIBCH, IDE, IFITM1, TYROBP, GNLY, TUBA1B pbmc_null <- FindNeighbors(object = pbmc_null) #> Computing nearest neighbor graph #> Computing SNN pbmc_null <- FindClusters(object = pbmc_null, resolution = 0.3) #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 453 #> Number of edges: 17874 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.7579 #> Number of communities: 2 #> Elapsed time: 0 seconds pbmc_null <- RunUMAP(object = pbmc_null, dims = 1:10) #> 01:07:26 UMAP embedding parameters a = 0.9922 b = 1.112 #> 01:07:26 Read 453 rows and found 10 numeric columns #> 01:07:26 Using Annoy for neighbor search, n_neighbors = 30 #> 01:07:26 Building Annoy index with metric = cosine, n_trees = 50 #> 0%   10   20   30   40   50   60   70   80   90   100% #> [----|----|----|----|----|----|----|----|----|----| #> **************************************************| #> 01:07:27 Writing NN index file to temp file /tmp/RtmpOiuxLd/file1bbb6897326a #> 01:07:27 Searching Annoy index using 1 thread, search_k = 3000 #> 01:07:27 Annoy recall = 100% #> 01:07:27 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30 #> 01:07:28 Initializing from normalized Laplacian + noise (using irlba) #> 01:07:28 Commencing optimization for 500 epochs, with 18082 positive edges #> 01:07:29 Optimization finished DimPlot(object = pbmc_null, reduction = \"umap\") null_markers <- FindMarkers(pbmc_null,                              ident.1 = 0,                              ident.2 = 1,                              min.pct = 0,                              logfc.threshold = 0) original_pval <- original_markers$p_val names(original_pval) <- rownames(original_markers)  null_pval <- null_markers$p_val names(null_pval) <- rownames(null_markers)  res <- ClusterDE::callDE(original_pval, null_pval, nlogTrans = TRUE) head(res$summaryTable) #> # A tibble: 6 × 5 #>   Gene   target   null    cs     q #>   <chr>   <dbl>  <dbl> <dbl> <dbl> #> 1 CD79B    53.1  0.247  52.9  0.04 #> 2 CDKN1C   67.5 18.6    48.9  0.04 #> 3 FCGR3A   79.0 31.2    47.8  0.04 #> 4 CKB      44.6  0.827  43.7  0.04 #> 5 RHOC     65.8 27.4    38.3  0.04 #> 6 PLD4     36.2  0.322  35.9  0.04 FeaturePlot(pbmc[ , pbmc$seurat_clusters %in% c(2, 8)], features = c(rownames(original_markers)[1:6]), ncol = 3) FeaturePlot(pbmc[, pbmc$seurat_clusters %in% c(2, 8)], features = c(res$summaryTable$Gene[1:6]), ncol = 3)"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-PBMC.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Perform ClusterDE on a PBMC dataset","text":"","code":"sessionInfo() #> R version 4.3.1 (2023-06-16) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Ubuntu 22.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> Random number generation: #>  RNG:     L'Ecuyer-CMRG  #>  Normal:  Inversion  #>  Sample:  Rejection  #>   #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] Matrix_1.6-1.1              patchwork_1.1.3             #>  [3] ggplot2_3.4.4               SingleCellExperiment_1.22.0 #>  [5] SummarizedExperiment_1.30.2 Biobase_2.60.0              #>  [7] GenomicRanges_1.52.1        GenomeInfoDb_1.36.4         #>  [9] IRanges_2.34.1              S4Vectors_0.38.2            #> [11] BiocGenerics_0.46.0         MatrixGenerics_1.12.3       #> [13] matrixStats_1.0.0           SeuratObject_4.1.4          #> [15] Seurat_4.4.0                ClusterDE_0.99.1            #> [17] BiocStyle_2.28.1            #>  #> loaded via a namespace (and not attached): #>   [1] RColorBrewer_1.1-3      jsonlite_1.8.7          magrittr_2.0.3          #>   [4] spatstat.utils_3.0-3    farver_2.1.1            rmarkdown_2.25          #>   [7] zlibbioc_1.46.0         fs_1.6.3                ragg_1.2.6              #>  [10] vctrs_0.6.4             ROCR_1.0-11             memoise_2.0.1           #>  [13] spatstat.explore_3.2-3  RCurl_1.98-1.12         S4Arrays_1.0.6          #>  [16] htmltools_0.5.6.1       sass_0.4.7              sctransform_0.4.0       #>  [19] parallelly_1.36.0       KernSmooth_2.23-21      bslib_0.5.1             #>  [22] htmlwidgets_1.6.2       desc_1.4.2              ica_1.0-3               #>  [25] plyr_1.8.9              plotly_4.10.2           zoo_1.8-12              #>  [28] cachem_1.0.8            igraph_1.5.1            mime_0.12               #>  [31] lifecycle_1.0.3         pkgconfig_2.0.3         R6_2.5.1                #>  [34] fastmap_1.1.1           GenomeInfoDbData_1.2.10 fitdistrplus_1.1-11     #>  [37] future_1.33.0           shiny_1.7.5             digest_0.6.33           #>  [40] colorspace_2.1-0        rprojroot_2.0.3         tensor_1.5              #>  [43] irlba_2.3.5.1           kde1d_1.0.5             textshaping_0.3.7       #>  [46] labeling_0.4.3          progressr_0.14.0        fansi_1.0.5             #>  [49] spatstat.sparse_3.0-2   httr_1.4.7              polyclip_1.10-6         #>  [52] abind_1.4-5             compiler_4.3.1          withr_2.5.1             #>  [55] MASS_7.3-60             DelayedArray_0.26.7     tools_4.3.1             #>  [58] lmtest_0.9-40           ape_5.7-1               httpuv_1.6.11           #>  [61] future.apply_1.11.0     goftest_1.2-3           glue_1.6.2              #>  [64] nlme_3.1-162            promises_1.2.1          grid_4.3.1              #>  [67] Rtsne_0.16              cluster_2.1.4           reshape2_1.4.4          #>  [70] generics_0.1.3          gtable_0.3.4            spatstat.data_3.0-1     #>  [73] tidyr_1.3.0             data.table_1.14.8       XVector_0.40.0          #>  [76] sp_2.1-0                utf8_1.2.3              spatstat.geom_3.2-5     #>  [79] RcppAnnoy_0.0.21        ggrepel_0.9.3           RANN_2.6.1              #>  [82] pillar_1.9.0            stringr_1.5.0           later_1.3.1             #>  [85] splines_4.3.1           dplyr_1.1.3             lattice_0.21-8          #>  [88] survival_3.5-5          deldir_1.0-9            tidyselect_1.2.0        #>  [91] miniUI_0.1.1.1          pbapply_1.7-2           knitr_1.44              #>  [94] gridExtra_2.3           bookdown_0.35           scattermore_1.2         #>  [97] xfun_0.40               stringi_1.7.12          lazyeval_0.2.2          #> [100] yaml_2.3.7              evaluate_0.22           codetools_0.2-19        #> [103] tibble_3.2.1            BiocManager_1.30.22     cli_3.6.1               #> [106] uwot_0.1.16             xtable_1.8-4            reticulate_1.34.0       #> [109] systemfonts_1.0.5       munsell_0.5.0           jquerylib_0.1.4         #> [112] Rcpp_1.0.11             globals_0.16.2          spatstat.random_3.1-6   #> [115] png_0.1-8               rngWELL_0.10-9          parallel_4.3.1          #> [118] ellipsis_0.3.2          randtoolbox_2.0.4       assertthat_0.2.1        #> [121] pkgdown_2.0.7           mvnfast_0.2.8           bitops_1.0-7            #> [124] listenv_0.9.0           viridisLite_0.4.2       scales_1.2.1            #> [127] ggridges_0.5.4          crayon_1.5.2            leiden_0.4.3            #> [130] purrr_1.0.2             rlang_1.1.1             rvinecopulib_0.6.3.1.1  #> [133] cowplot_1.1.1"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-cellline.html","id":"download-data","dir":"Articles","previous_headings":"","what":"Download data","title":"Perform ClusterDE on a cell line dataset","text":"download cell line data set H2228. original data Tian et al., Nature Methods 2019. Since data pure cell line, cell types, , course, cell type DE genes.","code":"sce <- readRDS(url(\"https://figshare.com/ndownloader/files/41395260\")) cellline <- Seurat::as.Seurat(sce) #> Warning: Keys should be one or more alphanumeric characters followed by an #> underscore, setting key from PC to PC_ #> Warning: All keys should be one or more alphanumeric characters followed by an #> underscore '_', setting key to PC_"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-cellline.html","id":"run-the-regular-seurat-pipeline","dir":"Articles","previous_headings":"","what":"Run the regular Seurat pipeline","title":"Perform ClusterDE on a cell line dataset","text":"perform default Seurat clustering. Please note ClusterDE designed 1 vs 1 comparison; therefore, set resolution 0.2 obtain two clusters illustration purpose. UMAP, two clusters seem dubious. Although expect existence cell types, perform Seurat DE test two clusters, get > 1000 genes FDR < 0.05. means double dipping introduces huge number discoveries.","code":"RNGkind(\"L'Ecuyer-CMRG\") set.seed(123) cellline <- NormalizeData(object = cellline) cellline <- FindVariableFeatures(object = cellline) cellline <- ScaleData(object = cellline) #> Centering and scaling data matrix cellline <- RunPCA(object = cellline) #> PC_ 1  #> Positive:  RPS14, RPL18AP3, RPL36, RPS23, RPL28, LRRC75A-AS1, AC079250.1, FTH1, ZFAS1, EEF2  #>     RPL7P9, RPL13A, RPS3AP26, EEF1A1P13, RPS16, RPS23P8, RPL13AP5, RPL29, FTH1P10, RPL13AP25  #>     SNHG5, FTH1P8, RPL4, RPS3AP6, AC064799.1, C6orf48, FTH1P7, C1orf56, RPL7AP6, TMSB4X  #> Negative:  PSMB2, PSMA7, U2AF1, NUDC, RBM8A, CALM1, BUB3, CLIC1, U2AF1L5, XRCC5  #>     VPS29, RBM8B, CACYBP, RPA3, SSBP1, PSMC5, MRPL47, PSMD8, BRIX1, CNIH4  #>     PCMT1, PSMD13, CYC1, PRDX2, SEPT7, S100A11, VDAC3, PSME2P2, ZWINT, HMGB1  #> PC_ 2  #> Positive:  NACA, RPL7AP6, SKP1, UBA52, BTF3, SSR2, RPL7A, ARPC3, RPL9P9, PPIA  #>     PSMD4, EIF1, RPL10, LGALS3BP, RPL10P16, SNRPB2, RPL10P9, S100A11, PPIB, ANXA5  #>     EEF2, PSME1, SSBP1, SSR4, RPL7P9, COPE, BSG, MGST1, VPS28, COPS6  #> Negative:  SIVA1, HNRNPAB, RPL39L, DEK, CDCA5, TMPO, FAM111A, ASF1B, CENPK, ESCO2  #>     BRCA1, H2AFV, RAD51AP1, MT-RNR2, ORC6, CENPX, SNRNP25, FBXO5, RRM1, DIAPH3  #>     USP1, CDCA4, TMEM106C, PGP, LSM4, C21orf58, CENPN, BRI3BP, SGO1, CHAF1A  #> PC_ 3  #> Positive:  RPL13AP5, RPL13AP25, AC024293.1, RPL29, RPSAP19, RPS5, RPL18, RPS3AP26, RPS3AP6, RPL15  #>     RPL28, DRAP1, RPS11, RPL9P9, RPL13AP7, RPS19, DCBLD2, FXYD5, FEN1, SLBP  #>     RPS15, COTL1, RPSA, FLNA, RPL7AP6, RPL36, C1orf21, CPA4, ORC6, RPS16  #> Negative:  SMIM22, TSPAN13, ST14, PERP, CRB3, MT-CO1, SERINC2, ATP1B1, CDH1, F11R  #>     B2M, MT-RNR2, SPINT1, NMB, PLA2G16, SPDEF, CD55, ADGRF1, TSPAN1, LIMA1  #>     ERBB3, ERO1A, ASS1, CDA, ALCAM, SYNGR2, MT-CO2, CDH3, C3, LSR  #> PC_ 4  #> Positive:  IFNGR1, NAMPT, NAP1L1, CPD, LMAN1, CALR, ITGA2, NAMPTP1, ITM2B, RRM1  #>     C3, RHOBTB3, CTHRC1, EEF2, HSD17B11, C1S, IFI16, SMC2, CPE, EPHX1  #>     DST, HLA-DMB, NUCB2, MT-ND6, TMEM45A, BRCA1, CDK5RAP2, HINT1, C1R, FAM111A  #> Negative:  S100A16, TMA7, TIMM8B, PFN1, SLIRP, GPX1, LAMC2, POLR2L, MRPL52, RPS19  #>     CDH1, TOMM40, ATP5MD, HSPE1, NAA10, GPX1P1, RPS16, MRPL12, MCRIP2, PDCD5  #>     RPL18, PLEC, S100A13, RPL36AL, LAD1, MGLL, BOLA2B, MISP, MRPL36, SEC61G  #> PC_ 5  #> Positive:  HINT1, COX5B, TXN, SOD1, NDUFA4, NDUFS6, ATP5PO, ATP5MC3, S100A10, ATP6V0E1  #>     CYB5A, SLIRP, NDUFB4, ATP5MC1, HSPE1, TXNP6, POMP, POLR2L, RPS14, HSPE1P4  #>     RPS15, CBR1, NDUFB3, HSPE1P3, ATP5PD, COX7B, ADGRF1, PSMB9, AC079250.1, NDUFAB1  #> Negative:  BTG1, PPP1R15A, EIF1, JUN, CEBPG, H3F3B, TMEM132A, C6orf48, HIST2H4B, SGK1  #>     KPNA4, PMEPA1, KLF6, CDKN1A, WARS, PEA15, GARS, MAP1LC3B, SNHG12, SERTAD1  #>     LAMC2, EPB41L4A-AS1, NAP1L1, SNHG5, KLF10, SLC7A5, KIF5B, ATP2B1, EIF5, ABL2 #> Warning: Cannot add objects with duplicate keys (offending key: PC_), setting #> key to 'pca_' cellline <- FindNeighbors(object = cellline) #> Computing nearest neighbor graph #> Computing SNN cellline <- FindClusters(object = cellline, resolution = 0.2) #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 758 #> Number of edges: 24895 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.8257 #> Number of communities: 2 #> Elapsed time: 0 seconds cellline <- RunUMAP(object = cellline, dims = 1:10) #> Warning: The default method for RunUMAP has changed from calling Python UMAP via reticulate to the R-native UWOT using the cosine metric #> To use Python UMAP via reticulate, set umap.method to 'umap-learn' and metric to 'correlation' #> This message will be shown once per session #> 01:08:39 UMAP embedding parameters a = 0.9922 b = 1.112 #> 01:08:39 Read 758 rows and found 10 numeric columns #> 01:08:39 Using Annoy for neighbor search, n_neighbors = 30 #> 01:08:39 Building Annoy index with metric = cosine, n_trees = 50 #> 0%   10   20   30   40   50   60   70   80   90   100% #> [----|----|----|----|----|----|----|----|----|----| #> **************************************************| #> 01:08:39 Writing NN index file to temp file /tmp/RtmpKj5gZZ/file1cc72b97d744 #> 01:08:39 Searching Annoy index using 1 thread, search_k = 3000 #> 01:08:39 Annoy recall = 100% #> 01:08:40 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30 #> 01:08:41 Initializing from normalized Laplacian + noise (using irlba) #> 01:08:41 Commencing optimization for 500 epochs, with 27914 positive edges #> 01:08:42 Optimization finished #> Warning: Cannot add objects with duplicate keys (offending key: UMAP_), setting #> key to 'umap_' DimPlot(object = cellline, reduction = \"umap\") + ggtitle(\"Clustering result\") original_markers <- FindMarkers(cellline,                                  ident.1 = 0,                                  ident.2 = 1,                                  min.pct = 0,                                  logfc.threshold = 0) #> For a more efficient implementation of the Wilcoxon Rank Sum Test, #> (default method for FindMarkers) please install the limma package #> -------------------------------------------- #> install.packages('BiocManager') #> BiocManager::install('limma') #> -------------------------------------------- #> After installation of limma, Seurat will automatically use the more  #> efficient implementation (no further action necessary). #> This message will be shown once per session print(sum(original_markers$p_val_adj < 0.05)) #> [1] 1023"},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-cellline.html","id":"generate-synthetic-null-data","dir":"Articles","previous_headings":"","what":"Generate synthetic null data","title":"Perform ClusterDE on a cell line dataset","text":"first generate synthetic null data based target data (real data). can increase number cores speed . perform pipeline target data. Please note need two clusters , . straightforward clustering method predefined cluster numbers, e.g., K-means. louvain clustering used Seurat may manually adjust resolution parameter still get two clusters. perform DE test synthetic null data. extract p-values original data synthetic null data, use ClusterDE “compare” . discover DE genes. can also visualize distribution contrast scores (diff -log p-values real null). roughly symmetric around 0.","code":"count_mat <- GetAssayData(object = cellline, slot = \"counts\") set.seed(123) system.time(synthetic_null <- ClusterDE::constructNull(count_mat, nCores = 2, fastVersion = TRUE, family = \"nb\")) #>    user  system elapsed  #> 173.531  44.039 115.019 cellline_null <- CreateSeuratObject(counts = synthetic_null)  set.seed(123) cellline_null <- NormalizeData(object = cellline_null) cellline_null <- FindVariableFeatures(object = cellline_null) cellline_null <- ScaleData(object = cellline_null) #> Centering and scaling data matrix cellline_null <- RunPCA(object = cellline_null) #> PC_ 1  #> Positive:  PSMB2, PSMC5, PSMA7, XRCC5, SKP1, PSMD8, NUDC, PSME2P2, U2AF1, VPS29  #>     CALM1, MRPL47, MGST1, CLIC1, CNIH4, SSBP1, RBM8A, TAGLN2, RPA3, COX5A  #>     PSME2, U2AF1L5, SNRPF, ARPC3, S100A11, PPIA, ATP5PD, MYL12B, RBM8B, ATP5PO  #> Negative:  LRRC75A-AS1, RPS14, FTH1, RPL29, RPL28, ZFAS1, RPL13A, FTH1P10, FTH1P7, RPS16  #>     EEF2, SNHG5, RPL13AP5, C1orf56, TMSB10, FTH1P8, MKNK2, STEAP2, TMSB4X, RPL32  #>     ASMTL, RPL13AP25, RPL4, NBPF10, C6orf48, NREP, VCAN, RPL9P9, ANKRD36B, HCFC1R1  #> PC_ 2  #> Positive:  SIVA1, RPL39L, CENPK, TMPO, HNRNPAB, DEK, ASF1B, H2AFV, CENPX, SNRNP25  #>     CKLF, TMEM106C, CHCHD2, CDCA5, FAM111A, RAD51AP1, RRM1, ZWINT, LSM4, SAC3D1  #>     CDCA4, BRI3BP, CENPN, SUZ12, BRCA1, PGP, ESCO2, ORC6, FBXO5, PRADC1  #> Negative:  NACA, RPL7AP6, RPL10, RPL7A, RPL10P16, RPL9P9, UBA52, BTF3, RPL10P9, SSR2  #>     EEF2, SKP1, RPL4, RPL18, LRRC75A-AS1, ANXA5, RPS4XP11, BSG, PSMD4, PPIB  #>     APEX1, ARPC3, EIF3M, SNRPB2, MYDGF, VPS28, CTSD, EDF1, PNRC1, EIF1  #> PC_ 3  #> Positive:  RPL29, RPL14, RPSAP19, RPL15, RPL13AP25, RPL32, RPL18, RPL13AP5, RPSA, DRAP1  #>     RPS5, RPS11, TMA7, CFL1, RPS19, FLNA, DCBLD2, RPL28, PFN1, RPS16  #>     PDCD5, SLBP, RPS15, PEBP1, AP2S1, FXYD5, BASP1, TMSB10, NME1, HSPE1P4  #> Negative:  ASS1, ADGRF1, C3, B2M, PERP, ATP1B1, CASP4, TSPAN13, CPD, LIPH  #>     SMIM22, EPS8, IFI16, GOLGB1, TMED10, NMB, SDC4, LIMA1, NMI, SPINT1  #>     TNFAIP2, CCDC186, CD55, HLA-DMB, F11R, NAMPT, SELENBP1, SQSTM1, SQOR, PLA2G16  #> PC_ 4  #> Positive:  S100A16, H3F3B, LAMC2, RPL36AL, PMEPA1, EIF5, TBRG1, RPL15, RNF145, ABRACL  #>     IMP4, SERTAD1, LAMB3, KDM5B, HMGB3, HIST1H2BD, DDX21, ZNF593, ZPR1, PFDN2  #>     HIST2H4B, TSSC4, GOT1, PLEC, HIST3H2A, ITGA6, OTUB1, ALCAM, COA6, EIF1  #> Negative:  IFNGR1, RFC4, NAMPT, BRCA1, EID1, POLD3, NDUFA4, HINT1, MCM3, ATP6V0E1  #>     RPA3, SOD1, CYB5A, DNMT1, CDT1, GMNN, CHAF1A, THYN1, CPD, CXXC5  #>     ADGRF1, ORC6, NAMPTP1, MCM6, CARHSP1, ACOT13, RPL7AP6, RHOBTB3, RMI2, NCOA7  #> PC_ 5  #> Positive:  MT-ND6, RAD21, DIAPH3, NDC80, ITGA2, C6orf48, KIF5B, NUCKS1, TMEM132A, RRM1  #>     ANP32E, NCAPG, CCDC88A, SPC25, ZNF622, SMC2, TATDN1P1, GARS, MTHFD2, CEP55  #>     C1orf56, SF3B2, VCAN, CEP57, CKAP2L, PIGK, NCAPD3, BCLAF1P2, TBC1D7, RTCB  #> Negative:  UQCRQ, NDUFS6, COX6B1, FTH1, FTH1P8, ATP5MC3, FTH1P10, APRT, COX7B, COX4I1  #>     ATP6V0E1, FTH1P7, NDUFB3, POLR2L, LY6E, SLIRP, PFN1, NMB, CHCHD10, HINT1  #>     ATP5MF, POMP, NDUFB4, MCRIP2, RPL36AL, MRPL23, S100A10, SEC61G, GPX4, DUSP23 cellline_null <- FindNeighbors(object = cellline_null) #> Computing nearest neighbor graph #> Computing SNN cellline_null <- FindClusters(object = cellline_null, resolution = 0.3) #> Modularity Optimizer version 1.3.0 by Ludo Waltman and Nees Jan van Eck #>  #> Number of nodes: 758 #> Number of edges: 29614 #>  #> Running Louvain algorithm... #> Maximum modularity in 10 random starts: 0.7309 #> Number of communities: 2 #> Elapsed time: 0 seconds cellline_null <- RunUMAP(object = cellline_null, dims = 1:10) #> 01:12:05 UMAP embedding parameters a = 0.9922 b = 1.112 #> 01:12:05 Read 758 rows and found 10 numeric columns #> 01:12:05 Using Annoy for neighbor search, n_neighbors = 30 #> 01:12:05 Building Annoy index with metric = cosine, n_trees = 50 #> 0%   10   20   30   40   50   60   70   80   90   100% #> [----|----|----|----|----|----|----|----|----|----| #> **************************************************| #> 01:12:05 Writing NN index file to temp file /tmp/RtmpKj5gZZ/file1cc778fbf7ec #> 01:12:05 Searching Annoy index using 1 thread, search_k = 3000 #> 01:12:05 Annoy recall = 100% #> 01:12:06 Commencing smooth kNN distance calibration using 1 thread with target n_neighbors = 30 #> 01:12:07 Initializing from normalized Laplacian + noise (using irlba) #> 01:12:07 Commencing optimization for 500 epochs, with 28370 positive edges #> 01:12:08 Optimization finished DimPlot(object = cellline_null, reduction = \"umap\") null_markers <- FindMarkers(cellline_null,                              ident.1 = 0,                              ident.2 = 1,                              min.pct = 0,                              logfc.threshold = 0) original_pval <- original_markers$p_val names(original_pval) <- rownames(original_markers)  null_pval <- null_markers$p_val names(null_pval) <- rownames(null_markers)  res <- ClusterDE::callDE(original_pval, null_pval, nlogTrans = TRUE) res$DEgenes #> character(0) ggplot(data = res$summaryTable, aes(x = cs)) + geom_histogram(fill = \"white\", color = \"black\") + theme_bw() + ggtitle(\"Distribution of constrast scores\") #> `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. #> Warning: Removed 1 rows containing non-finite values (`stat_bin()`)."},{"path":"https://songdongyuan1994.github.io/ClusterDE/articles/ClusterDE-cellline.html","id":"session-information","dir":"Articles","previous_headings":"","what":"Session information","title":"Perform ClusterDE on a cell line dataset","text":"","code":"sessionInfo() #> R version 4.3.1 (2023-06-16) #> Platform: x86_64-pc-linux-gnu (64-bit) #> Running under: Ubuntu 22.04.3 LTS #>  #> Matrix products: default #> BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  #> LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 #>  #> Random number generation: #>  RNG:     L'Ecuyer-CMRG  #>  Normal:  Inversion  #>  Sample:  Rejection  #>   #> locale: #>  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        #>  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    #>  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           #> [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    #>  #> time zone: UTC #> tzcode source: system (glibc) #>  #> attached base packages: #> [1] stats4    stats     graphics  grDevices utils     datasets  methods   #> [8] base      #>  #> other attached packages: #>  [1] ggplot2_3.4.4               SingleCellExperiment_1.22.0 #>  [3] SummarizedExperiment_1.30.2 Biobase_2.60.0              #>  [5] GenomicRanges_1.52.1        GenomeInfoDb_1.36.4         #>  [7] IRanges_2.34.1              S4Vectors_0.38.2            #>  [9] BiocGenerics_0.46.0         MatrixGenerics_1.12.3       #> [11] matrixStats_1.0.0           SeuratObject_4.1.4          #> [13] Seurat_4.4.0                ClusterDE_0.99.1            #> [15] BiocStyle_2.28.1            #>  #> loaded via a namespace (and not attached): #>   [1] RColorBrewer_1.1-3      jsonlite_1.8.7          magrittr_2.0.3          #>   [4] spatstat.utils_3.0-3    farver_2.1.1            rmarkdown_2.25          #>   [7] zlibbioc_1.46.0         fs_1.6.3                ragg_1.2.6              #>  [10] vctrs_0.6.4             ROCR_1.0-11             memoise_2.0.1           #>  [13] spatstat.explore_3.2-3  RCurl_1.98-1.12         S4Arrays_1.0.6          #>  [16] htmltools_0.5.6.1       sass_0.4.7              sctransform_0.4.0       #>  [19] parallelly_1.36.0       KernSmooth_2.23-21      bslib_0.5.1             #>  [22] htmlwidgets_1.6.2       desc_1.4.2              ica_1.0-3               #>  [25] plyr_1.8.9              plotly_4.10.2           zoo_1.8-12              #>  [28] cachem_1.0.8            igraph_1.5.1            mime_0.12               #>  [31] lifecycle_1.0.3         pkgconfig_2.0.3         Matrix_1.6-1.1          #>  [34] R6_2.5.1                fastmap_1.1.1           GenomeInfoDbData_1.2.10 #>  [37] fitdistrplus_1.1-11     future_1.33.0           shiny_1.7.5             #>  [40] digest_0.6.33           colorspace_2.1-0        patchwork_1.1.3         #>  [43] rprojroot_2.0.3         tensor_1.5              irlba_2.3.5.1           #>  [46] kde1d_1.0.5             textshaping_0.3.7       labeling_0.4.3          #>  [49] progressr_0.14.0        fansi_1.0.5             spatstat.sparse_3.0-2   #>  [52] httr_1.4.7              polyclip_1.10-6         abind_1.4-5             #>  [55] compiler_4.3.1          withr_2.5.1             MASS_7.3-60             #>  [58] DelayedArray_0.26.7     tools_4.3.1             lmtest_0.9-40           #>  [61] httpuv_1.6.11           future.apply_1.11.0     goftest_1.2-3           #>  [64] glue_1.6.2              nlme_3.1-162            promises_1.2.1          #>  [67] grid_4.3.1              Rtsne_0.16              cluster_2.1.4           #>  [70] reshape2_1.4.4          generics_0.1.3          gtable_0.3.4            #>  [73] spatstat.data_3.0-1     tidyr_1.3.0             data.table_1.14.8       #>  [76] XVector_0.40.0          sp_2.1-0                utf8_1.2.3              #>  [79] spatstat.geom_3.2-5     RcppAnnoy_0.0.21        ggrepel_0.9.3           #>  [82] RANN_2.6.1              pillar_1.9.0            stringr_1.5.0           #>  [85] later_1.3.1             splines_4.3.1           dplyr_1.1.3             #>  [88] lattice_0.21-8          survival_3.5-5          deldir_1.0-9            #>  [91] tidyselect_1.2.0        miniUI_0.1.1.1          pbapply_1.7-2           #>  [94] knitr_1.44              gridExtra_2.3           bookdown_0.35           #>  [97] scattermore_1.2         xfun_0.40               stringi_1.7.12          #> [100] lazyeval_0.2.2          yaml_2.3.7              evaluate_0.22           #> [103] codetools_0.2-19        tibble_3.2.1            BiocManager_1.30.22     #> [106] cli_3.6.1               uwot_0.1.16             xtable_1.8-4            #> [109] reticulate_1.34.0       systemfonts_1.0.5       munsell_0.5.0           #> [112] jquerylib_0.1.4         Rcpp_1.0.11             globals_0.16.2          #> [115] spatstat.random_3.1-6   png_0.1-8               rngWELL_0.10-9          #> [118] parallel_4.3.1          ellipsis_0.3.2          randtoolbox_2.0.4       #> [121] assertthat_0.2.1        pkgdown_2.0.7           mvnfast_0.2.8           #> [124] bitops_1.0-7            listenv_0.9.0           viridisLite_0.4.2       #> [127] scales_1.2.1            ggridges_0.5.4          crayon_1.5.2            #> [130] leiden_0.4.3            purrr_1.0.2             rlang_1.1.1             #> [133] rvinecopulib_0.6.3.1.1  cowplot_1.1.1"},{"path":"https://songdongyuan1994.github.io/ClusterDE/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Dongyuan Song. Author, maintainer. Kexin Li. Author.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Song D, Li K (2023). ClusterDE: Post-clustering Differential Expression (DE) Method Solving Double Dipping. https://github.com/SONGDONGYUAN1994/ClusterDE, https://songdongyuan1994.github.io/ClusterDE/.","code":"@Manual{,   title = {ClusterDE: A Post-clustering Differential Expression (DE) Method For Solving Double Dipping},   author = {Dongyuan Song and Kexin Li},   year = {2023},   note = {https://github.com/SONGDONGYUAN1994/ClusterDE, https://songdongyuan1994.github.io/ClusterDE/}, }"},{"path":"https://songdongyuan1994.github.io/ClusterDE/index.html","id":"clusterde","dir":"","previous_headings":"","what":"ClusterDE","title":"A Post-clustering Differential Expression (DE) Method For Solving Double Dipping","text":"R package ClusterDE post-clustering DE method controlling false discovery rate (FDR) identified cell-type DE genes regardless clustering quality. core idea ClusterDE generate real-data-based synthetic null data one cell type, contrast real data, evaluating whole procedure clustering followed DE test.  Detailed tutorials illustrate various functionalities ClusterDE available website. following illustration figure summarizes usage ClusterDE:  Instead new pipeline, ClusterDE actually works add-popular pipelines Seurat. find details ClusterDE, can check manuscript bioRxiv. motivation application ClusterDE: Seurat function findMarkers, authors pointed : “p-values interpreted cautiously, genes used clustering genes tested differential expression.” “double-dipping” issue. clustering results inaccurate since clustering used expression data already, discovered DE genes may represent discrete cell type separation, variation data (e.g., cell cycle, total UMI, variation clear. still biological variation define discrete status). ClusterDE aims correcting double-dipping issue comparing two dubious clusters, sure two discrete cell types just artifact clustering algorithm based conventional DE analysis. ClusterDE controls false discoveries DE prioritizes true cell type markers. Note: current version focusing one vs one comparison.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A Post-clustering Differential Expression (DE) Method For Solving Double Dipping","text":"install development version GitHub, please run: Please note ClusterDE actually wrapper scDesign3. Therefore, can also directly use scDesign3 “design” synthetic null data. better understand scDesign3, can check manuscript Nature Biotechnology: Song, D., Wang, Q., Yan, G. et al. scDesign3 generates realistic silico data multimodal single-cell spatial omics. Nat Biotechnol (2023).","code":"if (!require(\"devtools\", quietly = TRUE))     install.packages(\"devtools\") devtools::install_github(\"SONGDONGYUAN1994/scDesign3\") devtools::install_github(\"SONGDONGYUAN1994/ClusterDE\")"},{"path":"https://songdongyuan1994.github.io/ClusterDE/index.html","id":"quick-start","dir":"","previous_headings":"","what":"Quick Start","title":"A Post-clustering Differential Expression (DE) Method For Solving Double Dipping","text":"following code quick example generate synthetic null data. input data gene cell matrix containing two clusters want compare. input matrix count data (especially UMI counts), nb (Negative Binomial) usually appropriate choice. synthetic null data generation relatively time-consuming; may use fast version (fastVersion = TRUE). parameters constructNull() : mat: input gene cell matrix. can sparse matrix. family: string distribution want use fitting model. Must one ‘poisson’, ‘nb’, ‘zip’, ‘zinb’ ‘gaussian’. nCores: integer. number cores use. Increasing cores greatly speed computaion. parallelization: string indicating specific parallelization function use. Must one ‘mcmapply’, ‘bpmapply’, ‘pbmcmapply’, corresponds parallelization function package ‘parallel’, ‘BiocParallel’, ‘pbmcapply’ respectively. default value ‘pbmcmapply’. fastVersion: logic value. TRUE, fast approximation used. corrCut: numeric value. cutoff non-zero proportions genes used modelling correlation. reason lowly expressed genes hard calculate correlation. BPPARAM: MulticoreParam object NULL. parameter parallelization = ‘mcmapply’ ‘pbmcmapply’, parameter must NULL. parameter parallelization = ‘bpmapply’, parameter must one MulticoreParam object offered package ‘BiocParallel’. default value NULL. output constructNull() new gene cell matrix format input. following figure briefly describes ClusterDE generates synthetic null data:  obtaining synthetic null data, perform clustering procedure done real data get DE p-values (nullPvalues). Finally, compare p-values null p-values target data (real data) callDE(). illustration, use Uniform random numbers p-values. parameters callDE : targetScores: named numeric vector DE scores target data, e.g., p-values two clusters real data. nullScores: named numeric vector DE scores synthetic null data, e.g., p-values two clusters null data. nlogTrans: logical value. input scores p-values, take -log10 transformation since Clipper require larger scores represent significant DE. Default TRUE. FDR: numeric value target False Discovery Rate (FDR). Default 0.05. correct: logical value. TRUE, perform correction make distribution contrast scores approximately symmetric. Default FALSE. output callDE list target FDR, DE genes, detailed summary table.","code":"data(exampleCounts) nullData <- constructNull(mat = exampleCounts,                           family = \"nb\",                           nCores = 1,                           parallelization = \"pbmcmapply\",                           fastVersion = FALSE,                           corrCut = 0.2,                           BPPARAM = NULL) set.seed(123) targetPvalues <- runif(10000) nullPvalues <- runif(10000) names(targetPvalues) <- names(nullPvalues) <- paste0(\"Gene\", 1:10000) res <- callDE(targetScores = targetPvalues,               nullScores = nullPvalues,               nlogTrans = TRUE,               FDR = 0.05,               correct = FALSE)"},{"path":"https://songdongyuan1994.github.io/ClusterDE/index.html","id":"tutorials","dir":"","previous_headings":"","what":"Tutorials","title":"A Post-clustering Differential Expression (DE) Method For Solving Double Dipping","text":"detailed tutorials, please check website. tutorials demonstrate applications ClusterDE two cases: cell line dataset (cell type exists) PBMC dataset. Perform ClusterDE cell line dataset Perform ClusterDE PBMC dataset","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/index.html","id":"contact","dir":"","previous_headings":"","what":"Contact","title":"A Post-clustering Differential Expression (DE) Method For Solving Double Dipping","text":"questions suggestions ClusterDE welcomed! Please report issues, contact Dongyuan Song (dongyuansong@ucla.edu).","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/index.html","id":"related-papers","dir":"","previous_headings":"","what":"Related Papers","title":"A Post-clustering Differential Expression (DE) Method For Solving Double Dipping","text":"scDesign3: Song, D., Wang, Q., Yan, G. et al. scDesign3 generates realistic silico data multimodal single-cell spatial omics. Nat Biotechnol (2023). Clipper: Ge, X., Chen, Y.E., Song, D. et al. Clipper: p-value-free FDR control high-throughput data two conditions. Genome Biology 22, 288 (2021).","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/index.html","id":"other-methods-for-double-dipping-problem","dir":"","previous_headings":"","what":"Other methods for double dipping problem","title":"A Post-clustering Differential Expression (DE) Method For Solving Double Dipping","text":"TN test: Zhang, J.M., Kamath, G.M., David, N.T. Valid post-clustering differential analysis single-cell rna-seq. Cell Systems, 2019 count split: Neufeld, ., Gao, L.L., Popp, J., Battle, ., Witten, D. Inference latent variable estimation single-cell RNA sequencing data. Biostatistics, 2022","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/callDE.html","id":null,"dir":"Reference","previous_headings":"","what":"Call differentially expressed (DE) genes by Clipper algorithm — callDE","title":"Call differentially expressed (DE) genes by Clipper algorithm — callDE","text":"callDE takes two vectors representing gene's significance. usually p-values target data synthetic null data.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/callDE.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Call differentially expressed (DE) genes by Clipper algorithm — callDE","text":"","code":"callDE(   targetScores,   nullScores,   nlogTrans = TRUE,   FDR = 0.05,   correct = FALSE,   threshold = \"BC\" )"},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/callDE.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Call differentially expressed (DE) genes by Clipper algorithm — callDE","text":"targetScores named numeric vector DE scores target data, e.g., p-values two clusters real data. nullScores named numeric vector DE scores synthetic null data, e.g., p-values two clusters null data. nlogTrans logical value. input scores p-values, take -log10 transformation since Clipper require larger scores represent significant DE. Default TRUE. FDR numeric value target False Discovery Rate (FDR). Default 0.05. correct logical value. TRUE, perform correction make distribution contrast scores approximately symmetric. Default FALSE. threshold string value threshold method. Must 'BC' 'DS'.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/callDE.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Call differentially expressed (DE) genes by Clipper algorithm — callDE","text":"list target FDR, DE genes, detailed summary table.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/callDE.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Call differentially expressed (DE) genes by Clipper algorithm — callDE","text":"function constructs contrast scores taking difference target DE scores null DE scores.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/callDE.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Call differentially expressed (DE) genes by Clipper algorithm — callDE","text":"","code":"targetScores <- runif(10000) nullScores <- runif(10000) names(targetScores) <- names(nullScores) <- paste0(\"Gene\", 1:10000) res <- callDE(targetScores, nullScores, correct = FALSE)"},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/constructNull.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct the synthetic null data — constructNull","title":"Construct the synthetic null data — constructNull","text":"constructNull takes target data input returns corresponding synthetic null data.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/constructNull.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct the synthetic null data — constructNull","text":"","code":"constructNull(   mat,   family = \"nb\",   nCores = 1,   parallelization = \"pbmcmapply\",   fastVersion = FALSE,   corrCut = 0.2,   BPPARAM = NULL )"},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/constructNull.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct the synthetic null data — constructNull","text":"mat expression matrix (gene cell). can regular matrix sparseMatrix. family string vector strings distribution data. Must one 'nb', 'binomial', 'poisson', 'zip', 'zinb' 'gaussian', represent 'poisson distribution', 'negative binomial distribution', 'zero-inflated poisson distribution', 'zero-inflated negative binomail distribution', 'gaussian distribution' respectively. UMI-counts data, usually use 'nb'. Default 'nb'. nCores integer. number cores use Parallel processing. parallelization string indicating specific parallelization function use. Must one 'mcmapply', 'bpmapply', 'pbmcmapply', corresponds parallelization function package parallel,BiocParallel, pbmcapply respectively. default value 'pbmcmapply'. fastVersion logic value. TRUE, fast approximation used. Default FALSE. corrCut numeric value. cutoff non-zero proportions genes used modelling correlation. BPPARAM MulticoreParam object NULL. parameter parallelization = 'mcmapply' 'pbmcmapply', parameter must NULL. parameter parallelization = 'bpmapply',  parameter must one MulticoreParam object offered package 'BiocParallel. default value NULL.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/constructNull.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct the synthetic null data — constructNull","text":"expression matrix synthetic null data.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/constructNull.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Construct the synthetic null data — constructNull","text":"function constructs synthetic null data based target data (real data). input expression matrix (gene cell); user specify distribution, usually Negative Binomial count matrix.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/constructNull.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct the synthetic null data — constructNull","text":"","code":"data(exampleCounts) nullData <- constructNull(mat = exampleCounts) #> Input Data Construction Start #> Input Data Construction End #> Start Marginal Fitting #> Marginal Fitting End #> Start Copula Fitting #> Convert Residuals to Multivariate Gaussian #> Converting End #> Copula group 1 starts #> Copula Fitting End #> Start Parameter Extraction #> Parameter #> Extraction End #> Start Generate New Data #> Use Copula to sample a multivariate quantile matrix #> Sample Copula group 1 starts #> New Data Generating End"},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/exampleCounts.html","id":null,"dir":"Reference","previous_headings":"","what":"A count matrix of 100 genes from the A549 cell line from Tian et al., Nature Methods, 2019. — exampleCounts","title":"A count matrix of 100 genes from the A549 cell line from Tian et al., Nature Methods, 2019. — exampleCounts","text":"count matrix 100 genes A549 cell line Tian et al., Nature Methods, 2019.","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/exampleCounts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A count matrix of 100 genes from the A549 cell line from Tian et al., Nature Methods, 2019. — exampleCounts","text":"","code":"data(\"exampleCounts\")"},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/exampleCounts.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A count matrix of 100 genes from the A549 cell line from Tian et al., Nature Methods, 2019. — exampleCounts","text":"dataset 100 rows (genes) 1256 cols (cells)","code":""},{"path":"https://songdongyuan1994.github.io/ClusterDE/reference/exampleCounts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A count matrix of 100 genes from the A549 cell line from Tian et al., Nature Methods, 2019. — exampleCounts","text":"corresponding count matrix object","code":""}]
